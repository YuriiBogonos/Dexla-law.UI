"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-resizable-panels";
exports.ids = ["vendor-chunks/react-resizable-panels"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   PanelGroup: () => (/* binding */ PanelGroup),\n/* harmony export */   PanelResizeHandle: () => (/* binding */ PanelResizeHandle),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   getIntersectingRectangle: () => (/* binding */ getIntersectingRectangle),\n/* harmony export */   getPanelElement: () => (/* binding */ getPanelElement),\n/* harmony export */   getPanelElementsForGroup: () => (/* binding */ getPanelElementsForGroup),\n/* harmony export */   getPanelGroupElement: () => (/* binding */ getPanelGroupElement),\n/* harmony export */   getResizeHandleElement: () => (/* binding */ getResizeHandleElement),\n/* harmony export */   getResizeHandleElementIndex: () => (/* binding */ getResizeHandleElementIndex),\n/* harmony export */   getResizeHandleElementsForGroup: () => (/* binding */ getResizeHandleElementsForGroup),\n/* harmony export */   getResizeHandlePanelIds: () => (/* binding */ getResizeHandlePanelIds),\n/* harmony export */   intersects: () => (/* binding */ intersects)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n// eslint-disable-next-line no-restricted-imports\nconst { createElement, createContext, createRef, forwardRef, useCallback, useContext, useEffect, useImperativeHandle, useLayoutEffect, useMemo, useRef, useState } = react__WEBPACK_IMPORTED_MODULE_0__;\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = react__WEBPACK_IMPORTED_MODULE_0__[\"useId\".toString()];\n// The \"contextmenu\" event is not supported as a PointerEvent in all browsers yet, so MouseEvent still need to be handled\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\nconst wrappedUseId = typeof useId === \"function\" ? useId : ()=>null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n    const idFromUseId = wrappedUseId();\n    const idRef = useRef(idFromParams || idFromUseId || null);\n    if (idRef.current === null) {\n        idRef.current = \"\" + counter++;\n    }\n    return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\n}\nfunction PanelWithForwardedRef({ children, className: classNameFromProps = \"\", collapsedSize, collapsible, defaultSize, forwardedRef, id: idFromProps, maxSize, minSize, onCollapse, onExpand, onResize, order, style: styleFromProps, tagName: Type = \"div\", ...rest }) {\n    const context = useContext(PanelGroupContext);\n    if (context === null) {\n        throw Error(`Panel components must be rendered within a PanelGroup container`);\n    }\n    const { collapsePanel, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, reevaluatePanelConstraints, registerPanel, resizePanel, unregisterPanel } = context;\n    const panelId = useUniqueId(idFromProps);\n    const panelDataRef = useRef({\n        callbacks: {\n            onCollapse,\n            onExpand,\n            onResize\n        },\n        constraints: {\n            collapsedSize,\n            collapsible,\n            defaultSize,\n            maxSize,\n            minSize\n        },\n        id: panelId,\n        idIsFromProps: idFromProps !== undefined,\n        order\n    });\n    const devWarningsRef = useRef({\n        didLogMissingDefaultSizeWarning: false\n    });\n    // Normally we wouldn't log a warning during render,\n    // but effects don't run on the server, so we can't do it there\n    {\n        if (!devWarningsRef.current.didLogMissingDefaultSizeWarning) {\n            if (defaultSize == null) {\n                devWarningsRef.current.didLogMissingDefaultSizeWarning = true;\n                console.warn(`WARNING: Panel defaultSize prop recommended to avoid layout shift after server rendering`);\n            }\n        }\n    }\n    useImperativeHandle(forwardedRef, ()=>({\n            collapse: ()=>{\n                collapsePanel(panelDataRef.current);\n            },\n            expand: (minSize)=>{\n                expandPanel(panelDataRef.current, minSize);\n            },\n            getId () {\n                return panelId;\n            },\n            getSize () {\n                return getPanelSize(panelDataRef.current);\n            },\n            isCollapsed () {\n                return isPanelCollapsed(panelDataRef.current);\n            },\n            isExpanded () {\n                return !isPanelCollapsed(panelDataRef.current);\n            },\n            resize: (size)=>{\n                resizePanel(panelDataRef.current, size);\n            }\n        }), [\n        collapsePanel,\n        expandPanel,\n        getPanelSize,\n        isPanelCollapsed,\n        panelId,\n        resizePanel\n    ]);\n    const style = getPanelStyle(panelDataRef.current, defaultSize);\n    return createElement(Type, {\n        ...rest,\n        children,\n        className: classNameFromProps,\n        id: idFromProps,\n        style: {\n            ...style,\n            ...styleFromProps\n        },\n        // CSS selectors\n        \"data-panel\": \"\",\n        \"data-panel-collapsible\": collapsible || undefined,\n        \"data-panel-group-id\": groupId,\n        \"data-panel-id\": panelId,\n        \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1)\n    });\n}\nconst Panel = forwardRef((props, ref)=>createElement(PanelWithForwardedRef, {\n        ...props,\n        forwardedRef: ref\n    }));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\nlet currentCursorStyle = null;\nlet styleElement = null;\nfunction getCursorStyle(state, constraintFlags) {\n    if (constraintFlags) {\n        const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;\n        const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;\n        const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;\n        const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;\n        if (horizontalMin) {\n            if (verticalMin) {\n                return \"se-resize\";\n            } else if (verticalMax) {\n                return \"ne-resize\";\n            } else {\n                return \"e-resize\";\n            }\n        } else if (horizontalMax) {\n            if (verticalMin) {\n                return \"sw-resize\";\n            } else if (verticalMax) {\n                return \"nw-resize\";\n            } else {\n                return \"w-resize\";\n            }\n        } else if (verticalMin) {\n            return \"s-resize\";\n        } else if (verticalMax) {\n            return \"n-resize\";\n        }\n    }\n    switch(state){\n        case \"horizontal\":\n            return \"ew-resize\";\n        case \"intersection\":\n            return \"move\";\n        case \"vertical\":\n            return \"ns-resize\";\n    }\n}\nfunction resetGlobalCursorStyle() {\n    if (styleElement !== null) {\n        document.head.removeChild(styleElement);\n        currentCursorStyle = null;\n        styleElement = null;\n    }\n}\nfunction setGlobalCursorStyle(state, constraintFlags) {\n    const style = getCursorStyle(state, constraintFlags);\n    if (currentCursorStyle === style) {\n        return;\n    }\n    currentCursorStyle = style;\n    if (styleElement === null) {\n        styleElement = document.createElement(\"style\");\n        document.head.appendChild(styleElement);\n    }\n    styleElement.innerHTML = `*{cursor: ${style}!important;}`;\n}\nfunction isKeyDown(event) {\n    return event.type === \"keydown\";\n}\nfunction isPointerEvent(event) {\n    return event.type.startsWith(\"pointer\");\n}\nfunction isMouseEvent(event) {\n    return event.type.startsWith(\"mouse\");\n}\nfunction getResizeEventCoordinates(event) {\n    if (isPointerEvent(event)) {\n        if (event.isPrimary) {\n            return {\n                x: event.clientX,\n                y: event.clientY\n            };\n        }\n    } else if (isMouseEvent(event)) {\n        return {\n            x: event.clientX,\n            y: event.clientY\n        };\n    }\n    return {\n        x: Infinity,\n        y: Infinity\n    };\n}\nfunction getInputType() {\n    if (typeof matchMedia === \"function\") {\n        return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\n    }\n}\nfunction intersects(rectOne, rectTwo, strict) {\n    if (strict) {\n        return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;\n    } else {\n        return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;\n    }\n}\n// Forked from NPM stacking-order@2.0.0\n/**\n * Determine which of two nodes appears in front of the other —\n * if `a` is in front, returns 1, otherwise returns -1\n * @param {HTMLElement} a\n * @param {HTMLElement} b\n */ function compare(a, b) {\n    if (a === b) throw new Error(\"Cannot compare node with itself\");\n    const ancestors = {\n        a: get_ancestors(a),\n        b: get_ancestors(b)\n    };\n    let common_ancestor;\n    // remove shared ancestors\n    while(ancestors.a.at(-1) === ancestors.b.at(-1)){\n        a = ancestors.a.pop();\n        b = ancestors.b.pop();\n        common_ancestor = a;\n    }\n    assert(common_ancestor, \"Stacking order can only be calculated for elements with a common ancestor\");\n    const z_indexes = {\n        a: get_z_index(find_stacking_context(ancestors.a)),\n        b: get_z_index(find_stacking_context(ancestors.b))\n    };\n    if (z_indexes.a === z_indexes.b) {\n        const children = common_ancestor.childNodes;\n        const furthest_ancestors = {\n            a: ancestors.a.at(-1),\n            b: ancestors.b.at(-1)\n        };\n        let i = children.length;\n        while(i--){\n            const child = children[i];\n            if (child === furthest_ancestors.a) return 1;\n            if (child === furthest_ancestors.b) return -1;\n        }\n    }\n    return Math.sign(z_indexes.a - z_indexes.b);\n}\nconst props = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\n/** @param {HTMLElement} node */ function is_flex_item(node) {\n    var _get_parent;\n    // @ts-ignore\n    const display = getComputedStyle((_get_parent = get_parent(node)) !== null && _get_parent !== void 0 ? _get_parent : node).display;\n    return display === \"flex\" || display === \"inline-flex\";\n}\n/** @param {HTMLElement} node */ function creates_stacking_context(node) {\n    const style = getComputedStyle(node);\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n    if (style.position === \"fixed\") return true;\n    // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\n    // if (\n    //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\n    //   is_flex_item(node)\n    // )\n    if (style.zIndex !== \"auto\" && (style.position !== \"static\" || is_flex_item(node))) return true;\n    if (+style.opacity < 1) return true;\n    if (\"transform\" in style && style.transform !== \"none\") return true;\n    if (\"webkitTransform\" in style && style.webkitTransform !== \"none\") return true;\n    if (\"mixBlendMode\" in style && style.mixBlendMode !== \"normal\") return true;\n    if (\"filter\" in style && style.filter !== \"none\") return true;\n    if (\"webkitFilter\" in style && style.webkitFilter !== \"none\") return true;\n    if (\"isolation\" in style && style.isolation === \"isolate\") return true;\n    if (props.test(style.willChange)) return true;\n    // @ts-expect-error\n    if (style.webkitOverflowScrolling === \"touch\") return true;\n    return false;\n}\n/** @param {HTMLElement[]} nodes */ function find_stacking_context(nodes) {\n    let i = nodes.length;\n    while(i--){\n        const node = nodes[i];\n        assert(node, \"Missing node\");\n        if (creates_stacking_context(node)) return node;\n    }\n    return null;\n}\n/** @param {HTMLElement} node */ function get_z_index(node) {\n    return node && Number(getComputedStyle(node).zIndex) || 0;\n}\n/** @param {HTMLElement} node */ function get_ancestors(node) {\n    const ancestors = [];\n    while(node){\n        ancestors.push(node);\n        // @ts-ignore\n        node = get_parent(node);\n    }\n    return ancestors; // [ node, ... <body>, <html>, document ]\n}\n/** @param {HTMLElement} node */ function get_parent(node) {\n    const { parentNode } = node;\n    if (parentNode && parentNode instanceof ShadowRoot) {\n        return parentNode.host;\n    }\n    return parentNode;\n}\nconst EXCEEDED_HORIZONTAL_MIN = 1;\nconst EXCEEDED_HORIZONTAL_MAX = 2;\nconst EXCEEDED_VERTICAL_MIN = 4;\nconst EXCEEDED_VERTICAL_MAX = 8;\nconst isCoarsePointer = getInputType() === \"coarse\";\nlet intersectingHandles = [];\nlet isPointerDown = false;\nlet ownerDocumentCounts = new Map();\nlet panelConstraintFlags = new Map();\nconst registeredResizeHandlers = new Set();\nfunction registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {\n    var _ownerDocumentCounts$;\n    const { ownerDocument } = element;\n    const data = {\n        direction,\n        element,\n        hitAreaMargins,\n        setResizeHandlerState\n    };\n    const count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;\n    ownerDocumentCounts.set(ownerDocument, count + 1);\n    registeredResizeHandlers.add(data);\n    updateListeners();\n    return function unregisterResizeHandle() {\n        var _ownerDocumentCounts$2;\n        panelConstraintFlags.delete(resizeHandleId);\n        registeredResizeHandlers.delete(data);\n        const count = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;\n        ownerDocumentCounts.set(ownerDocument, count - 1);\n        updateListeners();\n        if (count === 1) {\n            ownerDocumentCounts.delete(ownerDocument);\n        }\n        // If the resize handle that is currently unmounting is intersecting with the pointer,\n        // update the global pointer to account for the change\n        if (intersectingHandles.includes(data)) {\n            const index = intersectingHandles.indexOf(data);\n            if (index >= 0) {\n                intersectingHandles.splice(index, 1);\n            }\n            updateCursor();\n        }\n    };\n}\nfunction handlePointerDown(event) {\n    const { target } = event;\n    const { x, y } = getResizeEventCoordinates(event);\n    isPointerDown = true;\n    recalculateIntersectingHandles({\n        target,\n        x,\n        y\n    });\n    updateListeners();\n    if (intersectingHandles.length > 0) {\n        updateResizeHandlerStates(\"down\", event);\n        event.preventDefault();\n        event.stopPropagation();\n    }\n}\nfunction handlePointerMove(event) {\n    const { x, y } = getResizeEventCoordinates(event);\n    if (!isPointerDown) {\n        const { target } = event;\n        // Recalculate intersecting handles whenever the pointer moves, except if it has already been pressed\n        // at that point, the handles may not move with the pointer (depending on constraints)\n        // but the same set of active handles should be locked until the pointer is released\n        recalculateIntersectingHandles({\n            target,\n            x,\n            y\n        });\n    }\n    updateResizeHandlerStates(\"move\", event);\n    // Update cursor based on return value(s) from active handles\n    updateCursor();\n    if (intersectingHandles.length > 0) {\n        event.preventDefault();\n    }\n}\nfunction handlePointerUp(event) {\n    const { target } = event;\n    const { x, y } = getResizeEventCoordinates(event);\n    panelConstraintFlags.clear();\n    isPointerDown = false;\n    if (intersectingHandles.length > 0) {\n        event.preventDefault();\n    }\n    updateResizeHandlerStates(\"up\", event);\n    recalculateIntersectingHandles({\n        target,\n        x,\n        y\n    });\n    updateCursor();\n    updateListeners();\n}\nfunction recalculateIntersectingHandles({ target, x, y }) {\n    intersectingHandles.splice(0);\n    let targetElement = null;\n    if (target instanceof HTMLElement) {\n        targetElement = target;\n    }\n    registeredResizeHandlers.forEach((data)=>{\n        const { element: dragHandleElement, hitAreaMargins } = data;\n        const dragHandleRect = dragHandleElement.getBoundingClientRect();\n        const { bottom, left, right, top } = dragHandleRect;\n        const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;\n        const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;\n        if (eventIntersects) {\n            // TRICKY\n            // We listen for pointers events at the root in order to support hit area margins\n            // (determining when the pointer is close enough to an element to be considered a \"hit\")\n            // Clicking on an element \"above\" a handle (e.g. a modal) should prevent a hit though\n            // so at this point we need to compare stacking order of a potentially intersecting drag handle,\n            // and the element that was actually clicked/touched\n            if (targetElement !== null && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) && // Calculating stacking order has a cost, so we should avoid it if possible\n            // That is why we only check potentially intersecting handles,\n            // and why we skip if the event target is within the handle's DOM\n            compare(targetElement, dragHandleElement) > 0) {\n                // If the target is above the drag handle, then we also need to confirm they overlap\n                // If they are beside each other (e.g. a panel and its drag handle) then the handle is still interactive\n                //\n                // It's not enough to compare only the target\n                // The target might be a small element inside of a larger container\n                // (For example, a SPAN or a DIV inside of a larger modal dialog)\n                let currentElement = targetElement;\n                let didIntersect = false;\n                while(currentElement){\n                    if (currentElement.contains(dragHandleElement)) {\n                        break;\n                    } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {\n                        didIntersect = true;\n                        break;\n                    }\n                    currentElement = currentElement.parentElement;\n                }\n                if (didIntersect) {\n                    return;\n                }\n            }\n            intersectingHandles.push(data);\n        }\n    });\n}\nfunction reportConstraintsViolation(resizeHandleId, flag) {\n    panelConstraintFlags.set(resizeHandleId, flag);\n}\nfunction updateCursor() {\n    let intersectsHorizontal = false;\n    let intersectsVertical = false;\n    intersectingHandles.forEach((data)=>{\n        const { direction } = data;\n        if (direction === \"horizontal\") {\n            intersectsHorizontal = true;\n        } else {\n            intersectsVertical = true;\n        }\n    });\n    let constraintFlags = 0;\n    panelConstraintFlags.forEach((flag)=>{\n        constraintFlags |= flag;\n    });\n    if (intersectsHorizontal && intersectsVertical) {\n        setGlobalCursorStyle(\"intersection\", constraintFlags);\n    } else if (intersectsHorizontal) {\n        setGlobalCursorStyle(\"horizontal\", constraintFlags);\n    } else if (intersectsVertical) {\n        setGlobalCursorStyle(\"vertical\", constraintFlags);\n    } else {\n        resetGlobalCursorStyle();\n    }\n}\nfunction updateListeners() {\n    ownerDocumentCounts.forEach((_, ownerDocument)=>{\n        const { body } = ownerDocument;\n        body.removeEventListener(\"contextmenu\", handlePointerUp);\n        body.removeEventListener(\"pointerdown\", handlePointerDown);\n        body.removeEventListener(\"pointerleave\", handlePointerMove);\n        body.removeEventListener(\"pointermove\", handlePointerMove);\n    });\n    window.removeEventListener(\"pointerup\", handlePointerUp);\n    window.removeEventListener(\"pointercancel\", handlePointerUp);\n    if (registeredResizeHandlers.size > 0) {\n        if (isPointerDown) {\n            if (intersectingHandles.length > 0) {\n                ownerDocumentCounts.forEach((count, ownerDocument)=>{\n                    const { body } = ownerDocument;\n                    if (count > 0) {\n                        body.addEventListener(\"contextmenu\", handlePointerUp);\n                        body.addEventListener(\"pointerleave\", handlePointerMove);\n                        body.addEventListener(\"pointermove\", handlePointerMove);\n                    }\n                });\n            }\n            window.addEventListener(\"pointerup\", handlePointerUp);\n            window.addEventListener(\"pointercancel\", handlePointerUp);\n        } else {\n            ownerDocumentCounts.forEach((count, ownerDocument)=>{\n                const { body } = ownerDocument;\n                if (count > 0) {\n                    body.addEventListener(\"pointerdown\", handlePointerDown, {\n                        capture: true\n                    });\n                    body.addEventListener(\"pointermove\", handlePointerMove);\n                }\n            });\n        }\n    }\n}\nfunction updateResizeHandlerStates(action, event) {\n    registeredResizeHandlers.forEach((data)=>{\n        const { setResizeHandlerState } = data;\n        const isActive = intersectingHandles.includes(data);\n        setResizeHandlerState(action, isActive, event);\n    });\n}\nfunction assert(expectedCondition, message) {\n    if (!expectedCondition) {\n        console.error(message);\n        throw Error(message);\n    }\n}\nconst PRECISION = 10;\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n    if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n        return 0;\n    } else {\n        return actual > expected ? 1 : -1;\n    }\n}\nfunction fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {\n    return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\n    return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\nfunction fuzzyLayoutsEqual(actual, expected, fractionDigits) {\n    if (actual.length !== expected.length) {\n        return false;\n    }\n    for(let index = 0; index < actual.length; index++){\n        const actualSize = actual[index];\n        const expectedSize = expected[index];\n        if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n            return false;\n        }\n    }\n    return true;\n}\n// Panel size must be in percentages; pixel values should be pre-converted\nfunction resizePanel({ panelConstraints: panelConstraintsArray, panelIndex, size }) {\n    const panelConstraints = panelConstraintsArray[panelIndex];\n    assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);\n    let { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = panelConstraints;\n    if (fuzzyCompareNumbers(size, minSize) < 0) {\n        if (collapsible) {\n            // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n            const halfwayPoint = (collapsedSize + minSize) / 2;\n            if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n                size = collapsedSize;\n            } else {\n                size = minSize;\n            }\n        } else {\n            size = minSize;\n        }\n    }\n    size = Math.min(maxSize, size);\n    size = parseFloat(size.toFixed(PRECISION));\n    return size;\n}\n// All units must be in percentages; pixel values should be pre-converted\nfunction adjustLayoutByDelta({ delta, initialLayout, panelConstraints: panelConstraintsArray, pivotIndices, prevLayout, trigger }) {\n    if (fuzzyNumbersEqual(delta, 0)) {\n        return initialLayout;\n    }\n    const nextLayout = [\n        ...initialLayout\n    ];\n    const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n    assert(firstPivotIndex != null, \"Invalid first pivot index\");\n    assert(secondPivotIndex != null, \"Invalid second pivot index\");\n    let deltaApplied = 0;\n    // const DEBUG = [];\n    // DEBUG.push(`adjustLayoutByDelta()`);\n    // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\n    // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\n    // DEBUG.push(`  delta: ${delta}`);\n    // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n    // DEBUG.push(`  trigger: ${trigger}`);\n    // DEBUG.push(\"\");\n    // A resizing panel affects the panels before or after it.\n    //\n    // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n    // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n    //\n    // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n    // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n    {\n        // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n        // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n        if (trigger === \"keyboard\") {\n            {\n                // Check if we should expand a collapsed panel\n                const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n                const panelConstraints = panelConstraintsArray[index];\n                assert(panelConstraints, `Panel constraints not found for index ${index}`);\n                const { collapsedSize = 0, collapsible, minSize = 0 } = panelConstraints;\n                // DEBUG.push(`edge case check 1: ${index}`);\n                // DEBUG.push(`  -> collapsible? ${collapsible}`);\n                if (collapsible) {\n                    const prevSize = initialLayout[index];\n                    assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n                    if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\n                        const localDelta = minSize - prevSize;\n                        // DEBUG.push(`  -> expand delta: ${localDelta}`);\n                        if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                        // DEBUG.push(`  -> delta: ${delta}`);\n                        }\n                    }\n                }\n            }\n            {\n                // Check if we should collapse a panel at its minimum size\n                const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n                const panelConstraints = panelConstraintsArray[index];\n                assert(panelConstraints, `No panel constraints found for index ${index}`);\n                const { collapsedSize = 0, collapsible, minSize = 0 } = panelConstraints;\n                // DEBUG.push(`edge case check 2: ${index}`);\n                // DEBUG.push(`  -> collapsible? ${collapsible}`);\n                if (collapsible) {\n                    const prevSize = initialLayout[index];\n                    assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n                    if (fuzzyNumbersEqual(prevSize, minSize)) {\n                        const localDelta = prevSize - collapsedSize;\n                        // DEBUG.push(`  -> expand delta: ${localDelta}`);\n                        if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                        // DEBUG.push(`  -> delta: ${delta}`);\n                        }\n                    }\n                }\n            }\n        }\n    // DEBUG.push(\"\");\n    }\n    {\n        // Pre-calculate max available delta in the opposite direction of our pivot.\n        // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n        // If this amount is less than the requested delta, adjust the requested delta.\n        // If this amount is greater than the requested delta, that's useful information too–\n        // as an expanding panel might change from collapsed to min size.\n        const increment = delta < 0 ? 1 : -1;\n        let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        let maxAvailableDelta = 0;\n        // DEBUG.push(\"pre calc...\");\n        while(true){\n            const prevSize = initialLayout[index];\n            assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n            const maxSafeSize = resizePanel({\n                panelConstraints: panelConstraintsArray,\n                panelIndex: index,\n                size: 100\n            });\n            const delta = maxSafeSize - prevSize;\n            // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n            maxAvailableDelta += delta;\n            index += increment;\n            if (index < 0 || index >= panelConstraintsArray.length) {\n                break;\n            }\n        }\n        // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n        const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n        delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n    }\n    {\n        // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n        const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        let index = pivotIndex;\n        while(index >= 0 && index < panelConstraintsArray.length){\n            const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n            const prevSize = initialLayout[index];\n            assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n            const unsafeSize = prevSize - deltaRemaining;\n            const safeSize = resizePanel({\n                panelConstraints: panelConstraintsArray,\n                panelIndex: index,\n                size: unsafeSize\n            });\n            if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n                deltaApplied += prevSize - safeSize;\n                nextLayout[index] = safeSize;\n                if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n                    numeric: true\n                }) >= 0) {\n                    break;\n                }\n            }\n            if (delta < 0) {\n                index--;\n            } else {\n                index++;\n            }\n        }\n    }\n    // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n    // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n    // DEBUG.push(\"\");\n    // If we were unable to resize any of the panels panels, return the previous state.\n    // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n    if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {\n        // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n        // console.log(DEBUG.join(\"\\n\"));\n        return prevLayout;\n    }\n    {\n        // Now distribute the applied delta to the panels in the other direction\n        const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const prevSize = initialLayout[pivotIndex];\n        assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);\n        const unsafeSize = prevSize + deltaApplied;\n        const safeSize = resizePanel({\n            panelConstraints: panelConstraintsArray,\n            panelIndex: pivotIndex,\n            size: unsafeSize\n        });\n        // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n        nextLayout[pivotIndex] = safeSize;\n        // Edge case where expanding or contracting one panel caused another one to change collapsed state\n        if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n            let deltaRemaining = unsafeSize - safeSize;\n            const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n            let index = pivotIndex;\n            while(index >= 0 && index < panelConstraintsArray.length){\n                const prevSize = nextLayout[index];\n                assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n                const unsafeSize = prevSize + deltaRemaining;\n                const safeSize = resizePanel({\n                    panelConstraints: panelConstraintsArray,\n                    panelIndex: index,\n                    size: unsafeSize\n                });\n                if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n                    deltaRemaining -= safeSize - prevSize;\n                    nextLayout[index] = safeSize;\n                }\n                if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n                    break;\n                }\n                if (delta > 0) {\n                    index--;\n                } else {\n                    index++;\n                }\n            }\n        }\n    }\n    // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n    // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n    // DEBUG.push(\"\");\n    const totalSize = nextLayout.reduce((total, size)=>size + total, 0);\n    // DEBUG.push(`total size: ${totalSize}`);\n    // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\n    // In that case, fall back to our most recent valid layout\n    if (!fuzzyNumbersEqual(totalSize, 100)) {\n        // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n        // console.log(DEBUG.join(\"\\n\"));\n        return prevLayout;\n    }\n    // console.log(DEBUG.join(\"\\n\"));\n    return nextLayout;\n}\nfunction getResizeHandleElementsForGroup(groupId, scope = document) {\n    return Array.from(scope.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\nfunction getResizeHandleElementIndex(groupId, id, scope = document) {\n    const handles = getResizeHandleElementsForGroup(groupId, scope);\n    const index = handles.findIndex((handle)=>handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n    return index !== null && index !== void 0 ? index : null;\n}\nfunction determinePivotIndices(groupId, dragHandleId, panelGroupElement) {\n    const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);\n    return index != null ? [\n        index,\n        index + 1\n    ] : [\n        -1,\n        -1\n    ];\n}\nfunction getPanelGroupElement(id, rootElement = document) {\n    var _dataset;\n    //If the root element is the PanelGroup\n    if (rootElement instanceof HTMLElement && (rootElement === null || rootElement === void 0 ? void 0 : (_dataset = rootElement.dataset) === null || _dataset === void 0 ? void 0 : _dataset.panelGroupId) == id) {\n        return rootElement;\n    }\n    //Else query children\n    const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction getResizeHandleElement(id, scope = document) {\n    const element = scope.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {\n    var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\n    const handle = getResizeHandleElement(handleId, scope);\n    const handles = getResizeHandleElementsForGroup(groupId, scope);\n    const index = handle ? handles.indexOf(handle) : -1;\n    const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\n    const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\n    return [\n        idBefore,\n        idAfter\n    ];\n}\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\nfunction useWindowSplitterPanelGroupBehavior({ committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, panelGroupElement, setLayout }) {\n    useRef({\n        didWarnAboutMissingResizeHandle: false\n    });\n    useEffect(()=>{\n        if (!panelGroupElement) {\n            return;\n        }\n        const eagerValues = eagerValuesRef.current;\n        assert(eagerValues, `Eager values not found`);\n        const { panelDataArray } = eagerValues;\n        const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n        assert(groupElement != null, `No group found for id \"${groupId}\"`);\n        const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n        assert(handles, `No resize handles found for group id \"${groupId}\"`);\n        const cleanupFunctions = handles.map((handle)=>{\n            const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n            assert(handleId, `Resize handle element has no handle id attribute`);\n            const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray, panelGroupElement);\n            if (idBefore == null || idAfter == null) {\n                return ()=>{};\n            }\n            const onKeyDown = (event)=>{\n                if (event.defaultPrevented) {\n                    return;\n                }\n                switch(event.key){\n                    case \"Enter\":\n                        {\n                            event.preventDefault();\n                            const index = panelDataArray.findIndex((panelData)=>panelData.id === idBefore);\n                            if (index >= 0) {\n                                const panelData = panelDataArray[index];\n                                assert(panelData, `No panel data found for index ${index}`);\n                                const size = layout[index];\n                                const { collapsedSize = 0, collapsible, minSize = 0 } = panelData.constraints;\n                                if (size != null && collapsible) {\n                                    const nextLayout = adjustLayoutByDelta({\n                                        delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n                                        initialLayout: layout,\n                                        panelConstraints: panelDataArray.map((panelData)=>panelData.constraints),\n                                        pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),\n                                        prevLayout: layout,\n                                        trigger: \"keyboard\"\n                                    });\n                                    if (layout !== nextLayout) {\n                                        setLayout(nextLayout);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                }\n            };\n            handle.addEventListener(\"keydown\", onKeyDown);\n            return ()=>{\n                handle.removeEventListener(\"keydown\", onKeyDown);\n            };\n        });\n        return ()=>{\n            cleanupFunctions.forEach((cleanupFunction)=>cleanupFunction());\n        };\n    }, [\n        panelGroupElement,\n        committedValuesRef,\n        eagerValuesRef,\n        groupId,\n        layout,\n        panelDataArray,\n        setLayout\n    ]);\n}\nfunction areEqual(arrayA, arrayB) {\n    if (arrayA.length !== arrayB.length) {\n        return false;\n    }\n    for(let index = 0; index < arrayA.length; index++){\n        if (arrayA[index] !== arrayB[index]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getResizeEventCursorPosition(direction, event) {\n    const isHorizontal = direction === \"horizontal\";\n    const { x, y } = getResizeEventCoordinates(event);\n    return isHorizontal ? x : y;\n}\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {\n    const isHorizontal = direction === \"horizontal\";\n    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);\n    assert(handleElement, `No resize handle element found for id \"${dragHandleId}\"`);\n    const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n    assert(groupId, `Resize handle element has no group id attribute`);\n    let { initialCursorPosition } = initialDragState;\n    const cursorPosition = getResizeEventCursorPosition(direction, event);\n    const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n    assert(groupElement, `No group element found for id \"${groupId}\"`);\n    const groupRect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n    const offsetPixels = cursorPosition - initialCursorPosition;\n    const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n    return offsetPercentage;\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {\n    if (isKeyDown(event)) {\n        const isHorizontal = direction === \"horizontal\";\n        let delta = 0;\n        if (event.shiftKey) {\n            delta = 100;\n        } else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n        } else {\n            delta = 10;\n        }\n        let movement = 0;\n        switch(event.key){\n            case \"ArrowDown\":\n                movement = isHorizontal ? 0 : delta;\n                break;\n            case \"ArrowLeft\":\n                movement = isHorizontal ? -delta : 0;\n                break;\n            case \"ArrowRight\":\n                movement = isHorizontal ? delta : 0;\n                break;\n            case \"ArrowUp\":\n                movement = isHorizontal ? 0 : -delta;\n                break;\n            case \"End\":\n                movement = 100;\n                break;\n            case \"Home\":\n                movement = -100;\n                break;\n        }\n        return movement;\n    } else {\n        if (initialDragState == null) {\n            return 0;\n        }\n        return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);\n    }\n}\n// Layout should be pre-converted into percentages\nfunction callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {\n    layout.forEach((size, index)=>{\n        const panelData = panelsArray[index];\n        assert(panelData, `Panel data not found for index ${index}`);\n        const { callbacks, constraints, id: panelId } = panelData;\n        const { collapsedSize = 0, collapsible } = constraints;\n        const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];\n        if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n            panelIdToLastNotifiedSizeMap[panelId] = size;\n            const { onCollapse, onExpand, onResize } = callbacks;\n            if (onResize) {\n                onResize(size, lastNotifiedSize);\n            }\n            if (collapsible && (onCollapse || onExpand)) {\n                if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size, collapsedSize)) {\n                    onExpand();\n                }\n                if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size, collapsedSize)) {\n                    onCollapse();\n                }\n            }\n        }\n    });\n}\nfunction compareLayouts(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    } else {\n        for(let index = 0; index < a.length; index++){\n            if (a[index] != b[index]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n// This method returns a number between 1 and 100 representing\n// the % of the group's overall space this panel should occupy.\nfunction computePanelFlexBoxStyle({ defaultSize, dragState, layout, panelData, panelIndex, precision = 3 }) {\n    const size = layout[panelIndex];\n    let flexGrow;\n    if (size == null) {\n        // Initial render (before panels have registered themselves)\n        // In order to support server rendering, fall back to default size if provided\n        flexGrow = defaultSize != undefined ? defaultSize.toPrecision(precision) : \"1\";\n    } else if (panelData.length === 1) {\n        // Special case: Single panel group should always fill full width/height\n        flexGrow = \"1\";\n    } else {\n        flexGrow = size.toPrecision(precision);\n    }\n    return {\n        flexBasis: 0,\n        flexGrow,\n        flexShrink: 1,\n        // Without this, Panel sizes may be unintentionally overridden by their content\n        overflow: \"hidden\",\n        // Disable pointer events inside of a panel during resize\n        // This avoid edge cases like nested iframes\n        pointerEvents: dragState !== null ? \"none\" : undefined\n    };\n}\nfunction debounce(callback, durationMs = 10) {\n    let timeoutId = null;\n    let callable = (...args)=>{\n        if (timeoutId !== null) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(()=>{\n            callback(...args);\n        }, durationMs);\n    };\n    return callable;\n}\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n    try {\n        if (typeof localStorage !== \"undefined\") {\n            // Bypass this check for future calls\n            storageObject.getItem = (name)=>{\n                return localStorage.getItem(name);\n            };\n            storageObject.setItem = (name, value)=>{\n                localStorage.setItem(name, value);\n            };\n        } else {\n            throw new Error(\"localStorage not supported in this environment\");\n        }\n    } catch (error) {\n        console.error(error);\n        storageObject.getItem = ()=>null;\n        storageObject.setItem = ()=>{};\n    }\n}\nfunction getPanelGroupKey(autoSaveId) {\n    return `react-resizable-panels:${autoSaveId}`;\n}\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels) {\n    return panels.map((panel)=>{\n        const { constraints, id, idIsFromProps, order } = panel;\n        if (idIsFromProps) {\n            return id;\n        } else {\n            return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);\n        }\n    }).sort((a, b)=>a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n    try {\n        const panelGroupKey = getPanelGroupKey(autoSaveId);\n        const serialized = storage.getItem(panelGroupKey);\n        if (serialized) {\n            const parsed = JSON.parse(serialized);\n            if (typeof parsed === \"object\" && parsed != null) {\n                return parsed;\n            }\n        }\n    } catch (error) {}\n    return null;\n}\nfunction savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {\n    var _loadSerializedPanelG2;\n    const panelGroupKey = getPanelGroupKey(autoSaveId);\n    const panelKey = getPanelKey(panels);\n    const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};\n    state[panelKey] = {\n        expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n        layout: sizes\n    };\n    try {\n        storage.setItem(panelGroupKey, JSON.stringify(state));\n    } catch (error) {\n        console.error(error);\n    }\n}\nfunction validatePanelConstraints({ panelConstraints: panelConstraintsArray, panelId, panelIndex }) {\n    {\n        const warnings = [];\n        const panelConstraints = panelConstraintsArray[panelIndex];\n        assert(panelConstraints, `No panel constraints found for index ${panelIndex}`);\n        const { collapsedSize = 0, collapsible = false, defaultSize, maxSize = 100, minSize = 0 } = panelConstraints;\n        if (minSize > maxSize) {\n            warnings.push(`min size (${minSize}%) should not be greater than max size (${maxSize}%)`);\n        }\n        if (defaultSize != null) {\n            if (defaultSize < 0) {\n                warnings.push(\"default size should not be less than 0\");\n            } else if (defaultSize < minSize && (!collapsible || defaultSize !== collapsedSize)) {\n                warnings.push(\"default size should not be less than min size\");\n            }\n            if (defaultSize > 100) {\n                warnings.push(\"default size should not be greater than 100\");\n            } else if (defaultSize > maxSize) {\n                warnings.push(\"default size should not be greater than max size\");\n            }\n        }\n        if (collapsedSize > minSize) {\n            warnings.push(\"collapsed size should not be greater than min size\");\n        }\n        if (warnings.length > 0) {\n            const name = panelId != null ? `Panel \"${panelId}\"` : \"Panel\";\n            console.warn(`${name} has an invalid configuration:\\n\\n${warnings.join(\"\\n\")}`);\n            return false;\n        }\n    }\n    return true;\n}\n// All units must be in percentages; pixel values should be pre-converted\nfunction validatePanelGroupLayout({ layout: prevLayout, panelConstraints }) {\n    const nextLayout = [\n        ...prevLayout\n    ];\n    const nextLayoutTotalSize = nextLayout.reduce((accumulated, current)=>accumulated + current, 0);\n    // Validate layout expectations\n    if (nextLayout.length !== panelConstraints.length) {\n        throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map((size)=>`${size}%`).join(\", \")}`);\n    } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100)) {\n        // This is not ideal so we should warn about it, but it may be recoverable in some cases\n        // (especially if the amount is small)\n        {\n            console.warn(`WARNING: Invalid layout total size: ${nextLayout.map((size)=>`${size}%`).join(\", \")}. Layout normalization will be applied.`);\n        }\n        for(let index = 0; index < panelConstraints.length; index++){\n            const unsafeSize = nextLayout[index];\n            assert(unsafeSize != null, `No layout data found for index ${index}`);\n            const safeSize = 100 / nextLayoutTotalSize * unsafeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    let remainingSize = 0;\n    // First pass: Validate the proposed layout given each panel's constraints\n    for(let index = 0; index < panelConstraints.length; index++){\n        const unsafeSize = nextLayout[index];\n        assert(unsafeSize != null, `No layout data found for index ${index}`);\n        const safeSize = resizePanel({\n            panelConstraints,\n            panelIndex: index,\n            size: unsafeSize\n        });\n        if (unsafeSize != safeSize) {\n            remainingSize += unsafeSize - safeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    // If there is additional, left over space, assign it to any panel(s) that permits it\n    // (It's not worth taking multiple additional passes to evenly distribute)\n    if (!fuzzyNumbersEqual(remainingSize, 0)) {\n        for(let index = 0; index < panelConstraints.length; index++){\n            const prevSize = nextLayout[index];\n            assert(prevSize != null, `No layout data found for index ${index}`);\n            const unsafeSize = prevSize + remainingSize;\n            const safeSize = resizePanel({\n                panelConstraints,\n                panelIndex: index,\n                size: unsafeSize\n            });\n            if (prevSize !== safeSize) {\n                remainingSize -= safeSize - prevSize;\n                nextLayout[index] = safeSize;\n                // Once we've used up the remainder, bail\n                if (fuzzyNumbersEqual(remainingSize, 0)) {\n                    break;\n                }\n            }\n        }\n    }\n    return nextLayout;\n}\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nconst defaultStorage = {\n    getItem: (name)=>{\n        initializeDefaultStorage(defaultStorage);\n        return defaultStorage.getItem(name);\n    },\n    setItem: (name, value)=>{\n        initializeDefaultStorage(defaultStorage);\n        defaultStorage.setItem(name, value);\n    }\n};\nconst debounceMap = {};\nfunction PanelGroupWithForwardedRef({ autoSaveId = null, children, className: classNameFromProps = \"\", direction, forwardedRef, id: idFromProps = null, onLayout = null, keyboardResizeBy = null, storage = defaultStorage, style: styleFromProps, tagName: Type = \"div\", ...rest }) {\n    const groupId = useUniqueId(idFromProps);\n    const panelGroupElementRef = useRef(null);\n    const [dragState, setDragState] = useState(null);\n    const [layout, setLayout] = useState([]);\n    const panelIdToLastNotifiedSizeMapRef = useRef({});\n    const panelSizeBeforeCollapseRef = useRef(new Map());\n    const prevDeltaRef = useRef(0);\n    const committedValuesRef = useRef({\n        autoSaveId,\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeBy,\n        onLayout,\n        storage\n    });\n    const eagerValuesRef = useRef({\n        layout,\n        panelDataArray: [],\n        panelDataArrayChanged: false\n    });\n    const devWarningsRef = useRef({\n        didLogIdAndOrderWarning: false,\n        didLogPanelConstraintsWarning: false,\n        prevPanelIds: []\n    });\n    useImperativeHandle(forwardedRef, ()=>({\n            getId: ()=>committedValuesRef.current.id,\n            getLayout: ()=>{\n                const { layout } = eagerValuesRef.current;\n                return layout;\n            },\n            setLayout: (unsafeLayout)=>{\n                const { onLayout } = committedValuesRef.current;\n                const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n                const safeLayout = validatePanelGroupLayout({\n                    layout: unsafeLayout,\n                    panelConstraints: panelDataArray.map((panelData)=>panelData.constraints)\n                });\n                if (!areEqual(prevLayout, safeLayout)) {\n                    setLayout(safeLayout);\n                    eagerValuesRef.current.layout = safeLayout;\n                    if (onLayout) {\n                        onLayout(safeLayout);\n                    }\n                    callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);\n                }\n            }\n        }), []);\n    useWindowSplitterPanelGroupBehavior({\n        committedValuesRef,\n        eagerValuesRef,\n        groupId,\n        layout,\n        panelDataArray: eagerValuesRef.current.panelDataArray,\n        setLayout,\n        panelGroupElement: panelGroupElementRef.current\n    });\n    useEffect(()=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        // If this panel has been configured to persist sizing information, save sizes to local storage.\n        if (autoSaveId) {\n            if (layout.length === 0 || layout.length !== panelDataArray.length) {\n                return;\n            }\n            let debouncedSave = debounceMap[autoSaveId];\n            // Limit the frequency of localStorage updates.\n            if (debouncedSave == null) {\n                debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n                debounceMap[autoSaveId] = debouncedSave;\n            }\n            // Clone mutable data before passing to the debounced function,\n            // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n            const clonedPanelDataArray = [\n                ...panelDataArray\n            ];\n            const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);\n            debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);\n        }\n    }, [\n        autoSaveId,\n        layout,\n        storage\n    ]);\n    // DEV warnings\n    useEffect(()=>{\n        {\n            const { panelDataArray } = eagerValuesRef.current;\n            const { didLogIdAndOrderWarning, didLogPanelConstraintsWarning, prevPanelIds } = devWarningsRef.current;\n            if (!didLogIdAndOrderWarning) {\n                const panelIds = panelDataArray.map(({ id })=>id);\n                devWarningsRef.current.prevPanelIds = panelIds;\n                const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\n                if (panelsHaveChanged) {\n                    if (panelDataArray.find(({ idIsFromProps, order })=>!idIsFromProps || order == null)) {\n                        devWarningsRef.current.didLogIdAndOrderWarning = true;\n                        console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);\n                    }\n                }\n            }\n            if (!didLogPanelConstraintsWarning) {\n                const panelConstraints = panelDataArray.map((panelData)=>panelData.constraints);\n                for(let panelIndex = 0; panelIndex < panelConstraints.length; panelIndex++){\n                    const panelData = panelDataArray[panelIndex];\n                    assert(panelData, `Panel data not found for index ${panelIndex}`);\n                    const isValid = validatePanelConstraints({\n                        panelConstraints,\n                        panelId: panelData.id,\n                        panelIndex\n                    });\n                    if (!isValid) {\n                        devWarningsRef.current.didLogPanelConstraintsWarning = true;\n                        break;\n                    }\n                }\n            }\n        }\n    });\n    // External APIs are safe to memoize via committed values ref\n    const collapsePanel = useCallback((panelData)=>{\n        const { onLayout } = committedValuesRef.current;\n        const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n        if (panelData.constraints.collapsible) {\n            const panelConstraintsArray = panelDataArray.map((panelData)=>panelData.constraints);\n            const { collapsedSize = 0, panelSize, pivotIndices } = panelDataHelper(panelDataArray, panelData, prevLayout);\n            assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n            if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n                // Store size before collapse;\n                // This is the size that gets restored if the expand() API is used.\n                panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);\n                const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n                const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n                const nextLayout = adjustLayoutByDelta({\n                    delta,\n                    initialLayout: prevLayout,\n                    panelConstraints: panelConstraintsArray,\n                    pivotIndices,\n                    prevLayout,\n                    trigger: \"imperative-api\"\n                });\n                if (!compareLayouts(prevLayout, nextLayout)) {\n                    setLayout(nextLayout);\n                    eagerValuesRef.current.layout = nextLayout;\n                    if (onLayout) {\n                        onLayout(nextLayout);\n                    }\n                    callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n                }\n            }\n        }\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const expandPanel = useCallback((panelData, minSizeOverride)=>{\n        const { onLayout } = committedValuesRef.current;\n        const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n        if (panelData.constraints.collapsible) {\n            const panelConstraintsArray = panelDataArray.map((panelData)=>panelData.constraints);\n            const { collapsedSize = 0, panelSize = 0, minSize: minSizeFromProps = 0, pivotIndices } = panelDataHelper(panelDataArray, panelData, prevLayout);\n            const minSize = minSizeOverride !== null && minSizeOverride !== void 0 ? minSizeOverride : minSizeFromProps;\n            if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n                // Restore this panel to the size it was before it was collapsed, if possible.\n                const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);\n                const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n                const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n                const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n                const nextLayout = adjustLayoutByDelta({\n                    delta,\n                    initialLayout: prevLayout,\n                    panelConstraints: panelConstraintsArray,\n                    pivotIndices,\n                    prevLayout,\n                    trigger: \"imperative-api\"\n                });\n                if (!compareLayouts(prevLayout, nextLayout)) {\n                    setLayout(nextLayout);\n                    eagerValuesRef.current.layout = nextLayout;\n                    if (onLayout) {\n                        onLayout(nextLayout);\n                    }\n                    callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n                }\n            }\n        }\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const getPanelSize = useCallback((panelData)=>{\n        const { layout, panelDataArray } = eagerValuesRef.current;\n        const { panelSize } = panelDataHelper(panelDataArray, panelData, layout);\n        assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n        return panelSize;\n    }, []);\n    // This API should never read from committedValuesRef\n    const getPanelStyle = useCallback((panelData, defaultSize)=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n        return computePanelFlexBoxStyle({\n            defaultSize,\n            dragState,\n            layout,\n            panelData: panelDataArray,\n            panelIndex\n        });\n    }, [\n        dragState,\n        layout\n    ]);\n    // External APIs are safe to memoize via committed values ref\n    const isPanelCollapsed = useCallback((panelData)=>{\n        const { layout, panelDataArray } = eagerValuesRef.current;\n        const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panelDataArray, panelData, layout);\n        assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n        return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const isPanelExpanded = useCallback((panelData)=>{\n        const { layout, panelDataArray } = eagerValuesRef.current;\n        const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panelDataArray, panelData, layout);\n        assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n        return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n    }, []);\n    const registerPanel = useCallback((panelData)=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        panelDataArray.push(panelData);\n        panelDataArray.sort((panelA, panelB)=>{\n            const orderA = panelA.order;\n            const orderB = panelB.order;\n            if (orderA == null && orderB == null) {\n                return 0;\n            } else if (orderA == null) {\n                return -1;\n            } else if (orderB == null) {\n                return 1;\n            } else {\n                return orderA - orderB;\n            }\n        });\n        eagerValuesRef.current.panelDataArrayChanged = true;\n    }, []);\n    const registerResizeHandle = useCallback((dragHandleId)=>{\n        return function resizeHandler(event) {\n            event.preventDefault();\n            const panelGroupElement = panelGroupElementRef.current;\n            if (!panelGroupElement) {\n                return ()=>null;\n            }\n            const { direction, dragState, id: groupId, keyboardResizeBy, onLayout } = committedValuesRef.current;\n            const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n            const { initialLayout } = dragState !== null && dragState !== void 0 ? dragState : {};\n            const pivotIndices = determinePivotIndices(groupId, dragHandleId, panelGroupElement);\n            let delta = calculateDeltaPercentage(event, dragHandleId, direction, dragState, keyboardResizeBy, panelGroupElement);\n            if (delta === 0) {\n                return;\n            }\n            // Support RTL layouts\n            const isHorizontal = direction === \"horizontal\";\n            if (document.dir === \"rtl\" && isHorizontal) {\n                delta = -delta;\n            }\n            const panelConstraints = panelDataArray.map((panelData)=>panelData.constraints);\n            const nextLayout = adjustLayoutByDelta({\n                delta,\n                initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\n                panelConstraints,\n                pivotIndices,\n                prevLayout,\n                trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\n            });\n            const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n            // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n            // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n            if (isPointerEvent(event) || isMouseEvent(event)) {\n                // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n                // In this case, Panel sizes might not change–\n                // but updating cursor in this scenario would cause a flicker.\n                if (prevDeltaRef.current != delta) {\n                    prevDeltaRef.current = delta;\n                    if (!layoutChanged) {\n                        // If the pointer has moved too far to resize the panel any further, note this so we can update the cursor.\n                        // This mimics VS Code behavior.\n                        if (isHorizontal) {\n                            reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);\n                        } else {\n                            reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);\n                        }\n                    } else {\n                        reportConstraintsViolation(dragHandleId, 0);\n                    }\n                }\n            }\n            if (layoutChanged) {\n                setLayout(nextLayout);\n                eagerValuesRef.current.layout = nextLayout;\n                if (onLayout) {\n                    onLayout(nextLayout);\n                }\n                callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n            }\n        };\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const resizePanel = useCallback((panelData, unsafePanelSize)=>{\n        const { onLayout } = committedValuesRef.current;\n        const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n        const panelConstraintsArray = panelDataArray.map((panelData)=>panelData.constraints);\n        const { panelSize, pivotIndices } = panelDataHelper(panelDataArray, panelData, prevLayout);\n        assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            initialLayout: prevLayout,\n            panelConstraints: panelConstraintsArray,\n            pivotIndices,\n            prevLayout,\n            trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n            setLayout(nextLayout);\n            eagerValuesRef.current.layout = nextLayout;\n            if (onLayout) {\n                onLayout(nextLayout);\n            }\n            callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n    }, []);\n    const reevaluatePanelConstraints = useCallback((panelData, prevConstraints)=>{\n        const { layout, panelDataArray } = eagerValuesRef.current;\n        const { collapsedSize: prevCollapsedSize = 0, collapsible: prevCollapsible } = prevConstraints;\n        const { collapsedSize: nextCollapsedSize = 0, collapsible: nextCollapsible, maxSize: nextMaxSize = 100, minSize: nextMinSize = 0 } = panelData.constraints;\n        const { panelSize: prevPanelSize } = panelDataHelper(panelDataArray, panelData, layout);\n        if (prevPanelSize == null) {\n            // It's possible that the panels in this group have changed since the last render\n            return;\n        }\n        if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {\n            if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {\n                resizePanel(panelData, nextCollapsedSize);\n            }\n        } else if (prevPanelSize < nextMinSize) {\n            resizePanel(panelData, nextMinSize);\n        } else if (prevPanelSize > nextMaxSize) {\n            resizePanel(panelData, nextMaxSize);\n        }\n    }, [\n        resizePanel\n    ]);\n    const startDragging = useCallback((dragHandleId, event)=>{\n        const { direction } = committedValuesRef.current;\n        const { layout } = eagerValuesRef.current;\n        if (!panelGroupElementRef.current) {\n            return;\n        }\n        const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);\n        assert(handleElement, `Drag handle element not found for id \"${dragHandleId}\"`);\n        const initialCursorPosition = getResizeEventCursorPosition(direction, event);\n        setDragState({\n            dragHandleId,\n            dragHandleRect: handleElement.getBoundingClientRect(),\n            initialCursorPosition,\n            initialLayout: layout\n        });\n    }, []);\n    const stopDragging = useCallback(()=>{\n        setDragState(null);\n    }, []);\n    const unregisterPanel = useCallback((panelData)=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        const index = findPanelDataIndex(panelDataArray, panelData);\n        if (index >= 0) {\n            panelDataArray.splice(index, 1);\n            // TRICKY\n            // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n            // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n            // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n            delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];\n            eagerValuesRef.current.panelDataArrayChanged = true;\n        }\n    }, []);\n    const context = useMemo(()=>({\n            collapsePanel,\n            direction,\n            dragState,\n            expandPanel,\n            getPanelSize,\n            getPanelStyle,\n            groupId,\n            isPanelCollapsed,\n            isPanelExpanded,\n            reevaluatePanelConstraints,\n            registerPanel,\n            registerResizeHandle,\n            resizePanel,\n            startDragging,\n            stopDragging,\n            unregisterPanel,\n            panelGroupElement: panelGroupElementRef.current\n        }), [\n        collapsePanel,\n        dragState,\n        direction,\n        expandPanel,\n        getPanelSize,\n        getPanelStyle,\n        groupId,\n        isPanelCollapsed,\n        isPanelExpanded,\n        reevaluatePanelConstraints,\n        registerPanel,\n        registerResizeHandle,\n        resizePanel,\n        startDragging,\n        stopDragging,\n        unregisterPanel\n    ]);\n    const style = {\n        display: \"flex\",\n        flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n        height: \"100%\",\n        overflow: \"hidden\",\n        width: \"100%\"\n    };\n    return createElement(PanelGroupContext.Provider, {\n        value: context\n    }, createElement(Type, {\n        ...rest,\n        children,\n        className: classNameFromProps,\n        id: idFromProps,\n        ref: panelGroupElementRef,\n        style: {\n            ...style,\n            ...styleFromProps\n        },\n        // CSS selectors\n        \"data-panel-group\": \"\",\n        \"data-panel-group-direction\": direction,\n        \"data-panel-group-id\": groupId\n    }));\n}\nconst PanelGroup = forwardRef((props, ref)=>createElement(PanelGroupWithForwardedRef, {\n        ...props,\n        forwardedRef: ref\n    }));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction findPanelDataIndex(panelDataArray, panelData) {\n    return panelDataArray.findIndex((prevPanelData)=>prevPanelData === panelData || prevPanelData.id === panelData.id);\n}\nfunction panelDataHelper(panelDataArray, panelData, layout) {\n    const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n    const isLastPanel = panelIndex === panelDataArray.length - 1;\n    const pivotIndices = isLastPanel ? [\n        panelIndex - 1,\n        panelIndex\n    ] : [\n        panelIndex,\n        panelIndex + 1\n    ];\n    const panelSize = layout[panelIndex];\n    return {\n        ...panelData.constraints,\n        panelSize,\n        pivotIndices\n    };\n}\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\nfunction useWindowSplitterResizeHandlerBehavior({ disabled, handleId, resizeHandler, panelGroupElement }) {\n    useEffect(()=>{\n        if (disabled || resizeHandler == null || panelGroupElement == null) {\n            return;\n        }\n        const handleElement = getResizeHandleElement(handleId, panelGroupElement);\n        if (handleElement == null) {\n            return;\n        }\n        const onKeyDown = (event)=>{\n            if (event.defaultPrevented) {\n                return;\n            }\n            switch(event.key){\n                case \"ArrowDown\":\n                case \"ArrowLeft\":\n                case \"ArrowRight\":\n                case \"ArrowUp\":\n                case \"End\":\n                case \"Home\":\n                    {\n                        event.preventDefault();\n                        resizeHandler(event);\n                        break;\n                    }\n                case \"F6\":\n                    {\n                        event.preventDefault();\n                        const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n                        assert(groupId, `No group element found for id \"${groupId}\"`);\n                        const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n                        const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);\n                        assert(index !== null, `No resize element found for id \"${handleId}\"`);\n                        const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n                        const nextHandle = handles[nextIndex];\n                        nextHandle.focus();\n                        break;\n                    }\n            }\n        };\n        handleElement.addEventListener(\"keydown\", onKeyDown);\n        return ()=>{\n            handleElement.removeEventListener(\"keydown\", onKeyDown);\n        };\n    }, [\n        panelGroupElement,\n        disabled,\n        handleId,\n        resizeHandler\n    ]);\n}\nfunction PanelResizeHandle({ children = null, className: classNameFromProps = \"\", disabled = false, hitAreaMargins, id: idFromProps, onBlur, onDragging, onFocus, style: styleFromProps = {}, tabIndex = 0, tagName: Type = \"div\", ...rest }) {\n    var _hitAreaMargins$coars, _hitAreaMargins$fine;\n    const elementRef = useRef(null);\n    // Use a ref to guard against users passing inline props\n    const callbacksRef = useRef({\n        onDragging\n    });\n    useEffect(()=>{\n        callbacksRef.current.onDragging = onDragging;\n    });\n    const panelGroupContext = useContext(PanelGroupContext);\n    if (panelGroupContext === null) {\n        throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n    }\n    const { direction, groupId, registerResizeHandle: registerResizeHandleWithParentGroup, startDragging, stopDragging, panelGroupElement } = panelGroupContext;\n    const resizeHandleId = useUniqueId(idFromProps);\n    const [state, setState] = useState(\"inactive\");\n    const [isFocused, setIsFocused] = useState(false);\n    const [resizeHandler, setResizeHandler] = useState(null);\n    const committedValuesRef = useRef({\n        state\n    });\n    useEffect(()=>{\n        if (disabled) {\n            setResizeHandler(null);\n        } else {\n            const resizeHandler = registerResizeHandleWithParentGroup(resizeHandleId);\n            setResizeHandler(()=>resizeHandler);\n        }\n    }, [\n        disabled,\n        resizeHandleId,\n        registerResizeHandleWithParentGroup\n    ]);\n    // Extract hit area margins before passing them to the effect's dependency array\n    // so that inline object values won't trigger re-renders\n    const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15;\n    const fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;\n    useEffect(()=>{\n        if (disabled || resizeHandler == null) {\n            return;\n        }\n        const element = elementRef.current;\n        assert(element, \"Element ref not attached\");\n        const setResizeHandlerState = (action, isActive, event)=>{\n            if (isActive) {\n                switch(action){\n                    case \"down\":\n                        {\n                            setState(\"drag\");\n                            startDragging(resizeHandleId, event);\n                            const { onDragging } = callbacksRef.current;\n                            if (onDragging) {\n                                onDragging(true);\n                            }\n                            break;\n                        }\n                    case \"move\":\n                        {\n                            const { state } = committedValuesRef.current;\n                            if (state !== \"drag\") {\n                                setState(\"hover\");\n                            }\n                            resizeHandler(event);\n                            break;\n                        }\n                    case \"up\":\n                        {\n                            setState(\"hover\");\n                            stopDragging();\n                            const { onDragging } = callbacksRef.current;\n                            if (onDragging) {\n                                onDragging(false);\n                            }\n                            break;\n                        }\n                }\n            } else {\n                setState(\"inactive\");\n            }\n        };\n        return registerResizeHandle(resizeHandleId, element, direction, {\n            coarse: coarseHitAreaMargins,\n            fine: fineHitAreaMargins\n        }, setResizeHandlerState);\n    }, [\n        coarseHitAreaMargins,\n        direction,\n        disabled,\n        fineHitAreaMargins,\n        registerResizeHandleWithParentGroup,\n        resizeHandleId,\n        resizeHandler,\n        startDragging,\n        stopDragging\n    ]);\n    useWindowSplitterResizeHandlerBehavior({\n        disabled,\n        handleId: resizeHandleId,\n        resizeHandler,\n        panelGroupElement\n    });\n    const style = {\n        touchAction: \"none\",\n        userSelect: \"none\"\n    };\n    return createElement(Type, {\n        ...rest,\n        children,\n        className: classNameFromProps,\n        id: idFromProps,\n        onBlur: ()=>{\n            setIsFocused(false);\n            onBlur === null || onBlur === void 0 ? void 0 : onBlur();\n        },\n        onFocus: ()=>{\n            setIsFocused(true);\n            onFocus === null || onFocus === void 0 ? void 0 : onFocus();\n        },\n        ref: elementRef,\n        role: \"separator\",\n        style: {\n            ...style,\n            ...styleFromProps\n        },\n        tabIndex,\n        // CSS selectors\n        \"data-panel-group-direction\": direction,\n        \"data-panel-group-id\": groupId,\n        \"data-resize-handle\": \"\",\n        \"data-resize-handle-active\": state === \"drag\" ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n        \"data-resize-handle-state\": state,\n        \"data-panel-resize-handle-enabled\": !disabled,\n        \"data-panel-resize-handle-id\": resizeHandleId\n    });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\nfunction getPanelElement(id, scope = document) {\n    const element = scope.querySelector(`[data-panel-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction getPanelElementsForGroup(groupId, scope = document) {\n    return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`));\n}\nfunction getIntersectingRectangle(rectOne, rectTwo, strict) {\n    if (!intersects(rectOne, rectTwo, strict)) {\n        return {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        };\n    }\n    return {\n        x: Math.max(rectOne.x, rectTwo.x),\n        y: Math.max(rectOne.y, rectTwo.y),\n        width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),\n        height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXphYmxlLXBhbmVscy9kaXN0L3JlYWN0LXJlc2l6YWJsZS1wYW5lbHMuZGV2ZWxvcG1lbnQubm9kZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBRS9CLGtHQUFrRztBQUVsRyxpREFBaUQ7QUFFakQsTUFBTSxFQUNKQyxhQUFhLEVBQ2JDLGFBQWEsRUFDYkMsU0FBUyxFQUNUQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyxTQUFTLEVBQ1RDLG1CQUFtQixFQUNuQkMsZUFBZSxFQUNmQyxPQUFPLEVBQ1BDLE1BQU0sRUFDTkMsUUFBUSxFQUNULEdBQUdaLGtDQUFLQTtBQUVULGdGQUFnRjtBQUNoRixNQUFNYSxRQUFRYixrQ0FBSyxDQUFDLFFBQVFjLFFBQVEsR0FBRztBQUV2Qyx5SEFBeUg7QUFFekgsTUFBTUMsb0JBQW9CYixjQUFjO0FBQ3hDYSxrQkFBa0JDLFdBQVcsR0FBRztBQUVoQyxNQUFNQyxlQUFlLE9BQU9KLFVBQVUsYUFBYUEsUUFBUSxJQUFNO0FBQ2pFLElBQUlLLFVBQVU7QUFDZCxTQUFTQyxZQUFZQyxlQUFlLElBQUk7SUFDdEMsTUFBTUMsY0FBY0o7SUFDcEIsTUFBTUssUUFBUVgsT0FBT1MsZ0JBQWdCQyxlQUFlO0lBQ3BELElBQUlDLE1BQU1DLE9BQU8sS0FBSyxNQUFNO1FBQzFCRCxNQUFNQyxPQUFPLEdBQUcsS0FBS0w7SUFDdkI7SUFDQSxPQUFPRSxpQkFBaUIsUUFBUUEsaUJBQWlCLEtBQUssSUFBSUEsZUFBZUUsTUFBTUMsT0FBTztBQUN4RjtBQUVBLFNBQVNDLHNCQUFzQixFQUM3QkMsUUFBUSxFQUNSQyxXQUFXQyxxQkFBcUIsRUFBRSxFQUNsQ0MsYUFBYSxFQUNiQyxXQUFXLEVBQ1hDLFdBQVcsRUFDWEMsWUFBWSxFQUNaQyxJQUFJQyxXQUFXLEVBQ2ZDLE9BQU8sRUFDUEMsT0FBTyxFQUNQQyxVQUFVLEVBQ1ZDLFFBQVEs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QUM7UUFDaENFLEdBQUc2QixLQUFLc1YsR0FBRyxDQUFDNVcsUUFBUVAsQ0FBQyxFQUFFUSxRQUFRUixDQUFDO1FBQ2hDVSxPQUFPbUIsS0FBS2lILEdBQUcsQ0FBQ3ZJLFFBQVFULENBQUMsR0FBR1MsUUFBUUcsS0FBSyxFQUFFRixRQUFRVixDQUFDLEdBQUdVLFFBQVFFLEtBQUssSUFBSW1CLEtBQUtzVixHQUFHLENBQUM1VyxRQUFRVCxDQUFDLEVBQUVVLFFBQVFWLENBQUM7UUFDckdhLFFBQVFrQixLQUFLaUgsR0FBRyxDQUFDdkksUUFBUVAsQ0FBQyxHQUFHTyxRQUFRSSxNQUFNLEVBQUVILFFBQVFSLENBQUMsR0FBR1EsUUFBUUcsTUFBTSxJQUFJa0IsS0FBS3NWLEdBQUcsQ0FBQzVXLFFBQVFQLENBQUMsRUFBRVEsUUFBUVIsQ0FBQztJQUMxRztBQUNGO0FBRThRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNpemFibGUtcGFuZWxzL2Rpc3QvcmVhY3QtcmVzaXphYmxlLXBhbmVscy5kZXZlbG9wbWVudC5ub2RlLmVzbS5qcz8xNTc2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLy8gVGhpcyBtb2R1bGUgZXhpc3RzIHRvIHdvcmsgYXJvdW5kIFdlYnBhY2sgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9pc3N1ZXMvMTQ4MTRcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtaW1wb3J0c1xuXG5jb25zdCB7XG4gIGNyZWF0ZUVsZW1lbnQsXG4gIGNyZWF0ZUNvbnRleHQsXG4gIGNyZWF0ZVJlZixcbiAgZm9yd2FyZFJlZixcbiAgdXNlQ2FsbGJhY2ssXG4gIHVzZUNvbnRleHQsXG4gIHVzZUVmZmVjdCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSxcbiAgdXNlTGF5b3V0RWZmZWN0LFxuICB1c2VNZW1vLFxuICB1c2VSZWYsXG4gIHVzZVN0YXRlXG59ID0gUmVhY3Q7XG5cbi8vIGB0b1N0cmluZygpYCBwcmV2ZW50cyBidW5kbGVycyBmcm9tIHRyeWluZyB0byBgaW1wb3J0IHsgdXNlSWQgfSBmcm9tICdyZWFjdCdgXG5jb25zdCB1c2VJZCA9IFJlYWN0W1widXNlSWRcIi50b1N0cmluZygpXTtcblxuLy8gVGhlIFwiY29udGV4dG1lbnVcIiBldmVudCBpcyBub3Qgc3VwcG9ydGVkIGFzIGEgUG9pbnRlckV2ZW50IGluIGFsbCBicm93c2VycyB5ZXQsIHNvIE1vdXNlRXZlbnQgc3RpbGwgbmVlZCB0byBiZSBoYW5kbGVkXG5cbmNvbnN0IFBhbmVsR3JvdXBDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcblBhbmVsR3JvdXBDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJQYW5lbEdyb3VwQ29udGV4dFwiO1xuXG5jb25zdCB3cmFwcGVkVXNlSWQgPSB0eXBlb2YgdXNlSWQgPT09IFwiZnVuY3Rpb25cIiA/IHVzZUlkIDogKCkgPT4gbnVsbDtcbmxldCBjb3VudGVyID0gMDtcbmZ1bmN0aW9uIHVzZVVuaXF1ZUlkKGlkRnJvbVBhcmFtcyA9IG51bGwpIHtcbiAgY29uc3QgaWRGcm9tVXNlSWQgPSB3cmFwcGVkVXNlSWQoKTtcbiAgY29uc3QgaWRSZWYgPSB1c2VSZWYoaWRGcm9tUGFyYW1zIHx8IGlkRnJvbVVzZUlkIHx8IG51bGwpO1xuICBpZiAoaWRSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgIGlkUmVmLmN1cnJlbnQgPSBcIlwiICsgY291bnRlcisrO1xuICB9XG4gIHJldHVybiBpZEZyb21QYXJhbXMgIT09IG51bGwgJiYgaWRGcm9tUGFyYW1zICE9PSB2b2lkIDAgPyBpZEZyb21QYXJhbXMgOiBpZFJlZi5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBQYW5lbFdpdGhGb3J3YXJkZWRSZWYoe1xuICBjaGlsZHJlbixcbiAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMgPSBcIlwiLFxuICBjb2xsYXBzZWRTaXplLFxuICBjb2xsYXBzaWJsZSxcbiAgZGVmYXVsdFNpemUsXG4gIGZvcndhcmRlZFJlZixcbiAgaWQ6IGlkRnJvbVByb3BzLFxuICBtYXhTaXplLFxuICBtaW5TaXplLFxuICBvbkNvbGxhcHNlLFxuICBvbkV4cGFuZCxcbiAgb25SZXNpemUsXG4gIG9yZGVyLFxuICBzdHlsZTogc3R5bGVGcm9tUHJvcHMsXG4gIHRhZ05hbWU6IFR5cGUgPSBcImRpdlwiLFxuICAuLi5yZXN0XG59KSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFBhbmVsR3JvdXBDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBFcnJvcihgUGFuZWwgY29tcG9uZW50cyBtdXN0IGJlIHJlbmRlcmVkIHdpdGhpbiBhIFBhbmVsR3JvdXAgY29udGFpbmVyYCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGNvbGxhcHNlUGFuZWwsXG4gICAgZXhwYW5kUGFuZWwsXG4gICAgZ2V0UGFuZWxTaXplLFxuICAgIGdldFBhbmVsU3R5bGUsXG4gICAgZ3JvdXBJZCxcbiAgICBpc1BhbmVsQ29sbGFwc2VkLFxuICAgIHJlZXZhbHVhdGVQYW5lbENvbnN0cmFpbnRzLFxuICAgIHJlZ2lzdGVyUGFuZWwsXG4gICAgcmVzaXplUGFuZWwsXG4gICAgdW5yZWdpc3RlclBhbmVsXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCBwYW5lbElkID0gdXNlVW5pcXVlSWQoaWRGcm9tUHJvcHMpO1xuICBjb25zdCBwYW5lbERhdGFSZWYgPSB1c2VSZWYoe1xuICAgIGNhbGxiYWNrczoge1xuICAgICAgb25Db2xsYXBzZSxcbiAgICAgIG9uRXhwYW5kLFxuICAgICAgb25SZXNpemVcbiAgICB9LFxuICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICBjb2xsYXBzZWRTaXplLFxuICAgICAgY29sbGFwc2libGUsXG4gICAgICBkZWZhdWx0U2l6ZSxcbiAgICAgIG1heFNpemUsXG4gICAgICBtaW5TaXplXG4gICAgfSxcbiAgICBpZDogcGFuZWxJZCxcbiAgICBpZElzRnJvbVByb3BzOiBpZEZyb21Qcm9wcyAhPT0gdW5kZWZpbmVkLFxuICAgIG9yZGVyXG4gIH0pO1xuICBjb25zdCBkZXZXYXJuaW5nc1JlZiA9IHVzZVJlZih7XG4gICAgZGlkTG9nTWlzc2luZ0RlZmF1bHRTaXplV2FybmluZzogZmFsc2VcbiAgfSk7XG5cbiAgLy8gTm9ybWFsbHkgd2Ugd291bGRuJ3QgbG9nIGEgd2FybmluZyBkdXJpbmcgcmVuZGVyLFxuICAvLyBidXQgZWZmZWN0cyBkb24ndCBydW4gb24gdGhlIHNlcnZlciwgc28gd2UgY2FuJ3QgZG8gaXQgdGhlcmVcbiAge1xuICAgIGlmICghZGV2V2FybmluZ3NSZWYuY3VycmVudC5kaWRMb2dNaXNzaW5nRGVmYXVsdFNpemVXYXJuaW5nKSB7XG4gICAgICBpZiAoZGVmYXVsdFNpemUgPT0gbnVsbCkge1xuICAgICAgICBkZXZXYXJuaW5nc1JlZi5jdXJyZW50LmRpZExvZ01pc3NpbmdEZWZhdWx0U2l6ZVdhcm5pbmcgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLndhcm4oYFdBUk5JTkc6IFBhbmVsIGRlZmF1bHRTaXplIHByb3AgcmVjb21tZW5kZWQgdG8gYXZvaWQgbGF5b3V0IHNoaWZ0IGFmdGVyIHNlcnZlciByZW5kZXJpbmdgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpID0+ICh7XG4gICAgY29sbGFwc2U6ICgpID0+IHtcbiAgICAgIGNvbGxhcHNlUGFuZWwocGFuZWxEYXRhUmVmLmN1cnJlbnQpO1xuICAgIH0sXG4gICAgZXhwYW5kOiBtaW5TaXplID0+IHtcbiAgICAgIGV4cGFuZFBhbmVsKHBhbmVsRGF0YVJlZi5jdXJyZW50LCBtaW5TaXplKTtcbiAgICB9LFxuICAgIGdldElkKCkge1xuICAgICAgcmV0dXJuIHBhbmVsSWQ7XG4gICAgfSxcbiAgICBnZXRTaXplKCkge1xuICAgICAgcmV0dXJuIGdldFBhbmVsU2l6ZShwYW5lbERhdGFSZWYuY3VycmVudCk7XG4gICAgfSxcbiAgICBpc0NvbGxhcHNlZCgpIHtcbiAgICAgIHJldHVybiBpc1BhbmVsQ29sbGFwc2VkKHBhbmVsRGF0YVJlZi5jdXJyZW50KTtcbiAgICB9LFxuICAgIGlzRXhwYW5kZWQoKSB7XG4gICAgICByZXR1cm4gIWlzUGFuZWxDb2xsYXBzZWQocGFuZWxEYXRhUmVmLmN1cnJlbnQpO1xuICAgIH0sXG4gICAgcmVzaXplOiBzaXplID0+IHtcbiAgICAgIHJlc2l6ZVBhbmVsKHBhbmVsRGF0YVJlZi5jdXJyZW50LCBzaXplKTtcbiAgICB9XG4gIH0pLCBbY29sbGFwc2VQYW5lbCwgZXhwYW5kUGFuZWwsIGdldFBhbmVsU2l6ZSwgaXNQYW5lbENvbGxhcHNlZCwgcGFuZWxJZCwgcmVzaXplUGFuZWxdKTtcbiAgY29uc3Qgc3R5bGUgPSBnZXRQYW5lbFN0eWxlKHBhbmVsRGF0YVJlZi5jdXJyZW50LCBkZWZhdWx0U2l6ZSk7XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFR5cGUsIHtcbiAgICAuLi5yZXN0LFxuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzLFxuICAgIGlkOiBpZEZyb21Qcm9wcyxcbiAgICBzdHlsZToge1xuICAgICAgLi4uc3R5bGUsXG4gICAgICAuLi5zdHlsZUZyb21Qcm9wc1xuICAgIH0sXG4gICAgLy8gQ1NTIHNlbGVjdG9yc1xuICAgIFwiZGF0YS1wYW5lbFwiOiBcIlwiLFxuICAgIFwiZGF0YS1wYW5lbC1jb2xsYXBzaWJsZVwiOiBjb2xsYXBzaWJsZSB8fCB1bmRlZmluZWQsXG4gICAgXCJkYXRhLXBhbmVsLWdyb3VwLWlkXCI6IGdyb3VwSWQsXG4gICAgXCJkYXRhLXBhbmVsLWlkXCI6IHBhbmVsSWQsXG4gICAgXCJkYXRhLXBhbmVsLXNpemVcIjogcGFyc2VGbG9hdChcIlwiICsgc3R5bGUuZmxleEdyb3cpLnRvRml4ZWQoMSlcbiAgfSk7XG59XG5jb25zdCBQYW5lbCA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IGNyZWF0ZUVsZW1lbnQoUGFuZWxXaXRoRm9yd2FyZGVkUmVmLCB7XG4gIC4uLnByb3BzLFxuICBmb3J3YXJkZWRSZWY6IHJlZlxufSkpO1xuUGFuZWxXaXRoRm9yd2FyZGVkUmVmLmRpc3BsYXlOYW1lID0gXCJQYW5lbFwiO1xuUGFuZWwuZGlzcGxheU5hbWUgPSBcImZvcndhcmRSZWYoUGFuZWwpXCI7XG5cbmxldCBjdXJyZW50Q3Vyc29yU3R5bGUgPSBudWxsO1xubGV0IHN0eWxlRWxlbWVudCA9IG51bGw7XG5mdW5jdGlvbiBnZXRDdXJzb3JTdHlsZShzdGF0ZSwgY29uc3RyYWludEZsYWdzKSB7XG4gIGlmIChjb25zdHJhaW50RmxhZ3MpIHtcbiAgICBjb25zdCBob3Jpem9udGFsTWluID0gKGNvbnN0cmFpbnRGbGFncyAmIEVYQ0VFREVEX0hPUklaT05UQUxfTUlOKSAhPT0gMDtcbiAgICBjb25zdCBob3Jpem9udGFsTWF4ID0gKGNvbnN0cmFpbnRGbGFncyAmIEVYQ0VFREVEX0hPUklaT05UQUxfTUFYKSAhPT0gMDtcbiAgICBjb25zdCB2ZXJ0aWNhbE1pbiA9IChjb25zdHJhaW50RmxhZ3MgJiBFWENFRURFRF9WRVJUSUNBTF9NSU4pICE9PSAwO1xuICAgIGNvbnN0IHZlcnRpY2FsTWF4ID0gKGNvbnN0cmFpbnRGbGFncyAmIEVYQ0VFREVEX1ZFUlRJQ0FMX01BWCkgIT09IDA7XG4gICAgaWYgKGhvcml6b250YWxNaW4pIHtcbiAgICAgIGlmICh2ZXJ0aWNhbE1pbikge1xuICAgICAgICByZXR1cm4gXCJzZS1yZXNpemVcIjtcbiAgICAgIH0gZWxzZSBpZiAodmVydGljYWxNYXgpIHtcbiAgICAgICAgcmV0dXJuIFwibmUtcmVzaXplXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJlLXJlc2l6ZVwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaG9yaXpvbnRhbE1heCkge1xuICAgICAgaWYgKHZlcnRpY2FsTWluKSB7XG4gICAgICAgIHJldHVybiBcInN3LXJlc2l6ZVwiO1xuICAgICAgfSBlbHNlIGlmICh2ZXJ0aWNhbE1heCkge1xuICAgICAgICByZXR1cm4gXCJudy1yZXNpemVcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcInctcmVzaXplXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2ZXJ0aWNhbE1pbikge1xuICAgICAgcmV0dXJuIFwicy1yZXNpemVcIjtcbiAgICB9IGVsc2UgaWYgKHZlcnRpY2FsTWF4KSB7XG4gICAgICByZXR1cm4gXCJuLXJlc2l6ZVwiO1xuICAgIH1cbiAgfVxuICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgY2FzZSBcImhvcml6b250YWxcIjpcbiAgICAgIHJldHVybiBcImV3LXJlc2l6ZVwiO1xuICAgIGNhc2UgXCJpbnRlcnNlY3Rpb25cIjpcbiAgICAgIHJldHVybiBcIm1vdmVcIjtcbiAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgIHJldHVybiBcIm5zLXJlc2l6ZVwiO1xuICB9XG59XG5mdW5jdGlvbiByZXNldEdsb2JhbEN1cnNvclN0eWxlKCkge1xuICBpZiAoc3R5bGVFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgIGN1cnJlbnRDdXJzb3JTdHlsZSA9IG51bGw7XG4gICAgc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gc2V0R2xvYmFsQ3Vyc29yU3R5bGUoc3RhdGUsIGNvbnN0cmFpbnRGbGFncykge1xuICBjb25zdCBzdHlsZSA9IGdldEN1cnNvclN0eWxlKHN0YXRlLCBjb25zdHJhaW50RmxhZ3MpO1xuICBpZiAoY3VycmVudEN1cnNvclN0eWxlID09PSBzdHlsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdXJyZW50Q3Vyc29yU3R5bGUgPSBzdHlsZTtcbiAgaWYgKHN0eWxlRWxlbWVudCA9PT0gbnVsbCkge1xuICAgIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gIH1cbiAgc3R5bGVFbGVtZW50LmlubmVySFRNTCA9IGAqe2N1cnNvcjogJHtzdHlsZX0haW1wb3J0YW50O31gO1xufVxuXG5mdW5jdGlvbiBpc0tleURvd24oZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUgPT09IFwia2V5ZG93blwiO1xufVxuZnVuY3Rpb24gaXNQb2ludGVyRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUuc3RhcnRzV2l0aChcInBvaW50ZXJcIik7XG59XG5mdW5jdGlvbiBpc01vdXNlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUuc3RhcnRzV2l0aChcIm1vdXNlXCIpO1xufVxuXG5mdW5jdGlvbiBnZXRSZXNpemVFdmVudENvb3JkaW5hdGVzKGV2ZW50KSB7XG4gIGlmIChpc1BvaW50ZXJFdmVudChldmVudCkpIHtcbiAgICBpZiAoZXZlbnQuaXNQcmltYXJ5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IEluZmluaXR5LFxuICAgIHk6IEluZmluaXR5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldElucHV0VHlwZSgpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaE1lZGlhID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gbWF0Y2hNZWRpYShcIihwb2ludGVyOmNvYXJzZSlcIikubWF0Y2hlcyA/IFwiY29hcnNlXCIgOiBcImZpbmVcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKHJlY3RPbmUsIHJlY3RUd28sIHN0cmljdCkge1xuICBpZiAoc3RyaWN0KSB7XG4gICAgcmV0dXJuIHJlY3RPbmUueCA8IHJlY3RUd28ueCArIHJlY3RUd28ud2lkdGggJiYgcmVjdE9uZS54ICsgcmVjdE9uZS53aWR0aCA+IHJlY3RUd28ueCAmJiByZWN0T25lLnkgPCByZWN0VHdvLnkgKyByZWN0VHdvLmhlaWdodCAmJiByZWN0T25lLnkgKyByZWN0T25lLmhlaWdodCA+IHJlY3RUd28ueTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVjdE9uZS54IDw9IHJlY3RUd28ueCArIHJlY3RUd28ud2lkdGggJiYgcmVjdE9uZS54ICsgcmVjdE9uZS53aWR0aCA+PSByZWN0VHdvLnggJiYgcmVjdE9uZS55IDw9IHJlY3RUd28ueSArIHJlY3RUd28uaGVpZ2h0ICYmIHJlY3RPbmUueSArIHJlY3RPbmUuaGVpZ2h0ID49IHJlY3RUd28ueTtcbiAgfVxufVxuXG4vLyBGb3JrZWQgZnJvbSBOUE0gc3RhY2tpbmctb3JkZXJAMi4wLjBcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hpY2ggb2YgdHdvIG5vZGVzIGFwcGVhcnMgaW4gZnJvbnQgb2YgdGhlIG90aGVyIOKAlFxuICogaWYgYGFgIGlzIGluIGZyb250LCByZXR1cm5zIDEsIG90aGVyd2lzZSByZXR1cm5zIC0xXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBiXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXBhcmUgbm9kZSB3aXRoIGl0c2VsZlwiKTtcbiAgY29uc3QgYW5jZXN0b3JzID0ge1xuICAgIGE6IGdldF9hbmNlc3RvcnMoYSksXG4gICAgYjogZ2V0X2FuY2VzdG9ycyhiKVxuICB9O1xuICBsZXQgY29tbW9uX2FuY2VzdG9yO1xuXG4gIC8vIHJlbW92ZSBzaGFyZWQgYW5jZXN0b3JzXG4gIHdoaWxlIChhbmNlc3RvcnMuYS5hdCgtMSkgPT09IGFuY2VzdG9ycy5iLmF0KC0xKSkge1xuICAgIGEgPSBhbmNlc3RvcnMuYS5wb3AoKTtcbiAgICBiID0gYW5jZXN0b3JzLmIucG9wKCk7XG4gICAgY29tbW9uX2FuY2VzdG9yID0gYTtcbiAgfVxuICBhc3NlcnQoY29tbW9uX2FuY2VzdG9yLCBcIlN0YWNraW5nIG9yZGVyIGNhbiBvbmx5IGJlIGNhbGN1bGF0ZWQgZm9yIGVsZW1lbnRzIHdpdGggYSBjb21tb24gYW5jZXN0b3JcIik7XG4gIGNvbnN0IHpfaW5kZXhlcyA9IHtcbiAgICBhOiBnZXRfel9pbmRleChmaW5kX3N0YWNraW5nX2NvbnRleHQoYW5jZXN0b3JzLmEpKSxcbiAgICBiOiBnZXRfel9pbmRleChmaW5kX3N0YWNraW5nX2NvbnRleHQoYW5jZXN0b3JzLmIpKVxuICB9O1xuICBpZiAoel9pbmRleGVzLmEgPT09IHpfaW5kZXhlcy5iKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBjb21tb25fYW5jZXN0b3IuY2hpbGROb2RlcztcbiAgICBjb25zdCBmdXJ0aGVzdF9hbmNlc3RvcnMgPSB7XG4gICAgICBhOiBhbmNlc3RvcnMuYS5hdCgtMSksXG4gICAgICBiOiBhbmNlc3RvcnMuYi5hdCgtMSlcbiAgICB9O1xuICAgIGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQgPT09IGZ1cnRoZXN0X2FuY2VzdG9ycy5hKSByZXR1cm4gMTtcbiAgICAgIGlmIChjaGlsZCA9PT0gZnVydGhlc3RfYW5jZXN0b3JzLmIpIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE1hdGguc2lnbih6X2luZGV4ZXMuYSAtIHpfaW5kZXhlcy5iKTtcbn1cbmNvbnN0IHByb3BzID0gL1xcYig/OnBvc2l0aW9ufHpJbmRleHxvcGFjaXR5fHRyYW5zZm9ybXx3ZWJraXRUcmFuc2Zvcm18bWl4QmxlbmRNb2RlfGZpbHRlcnx3ZWJraXRGaWx0ZXJ8aXNvbGF0aW9uKVxcYi87XG5cbi8qKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlICovXG5mdW5jdGlvbiBpc19mbGV4X2l0ZW0obm9kZSkge1xuICB2YXIgX2dldF9wYXJlbnQ7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgZGlzcGxheSA9IGdldENvbXB1dGVkU3R5bGUoKF9nZXRfcGFyZW50ID0gZ2V0X3BhcmVudChub2RlKSkgIT09IG51bGwgJiYgX2dldF9wYXJlbnQgIT09IHZvaWQgMCA/IF9nZXRfcGFyZW50IDogbm9kZSkuZGlzcGxheTtcbiAgcmV0dXJuIGRpc3BsYXkgPT09IFwiZmxleFwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWZsZXhcIjtcbn1cblxuLyoqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgKi9cbmZ1bmN0aW9uIGNyZWF0ZXNfc3RhY2tpbmdfY29udGV4dChub2RlKSB7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ1NTX1Bvc2l0aW9uaW5nL1VuZGVyc3RhbmRpbmdfel9pbmRleC9UaGVfc3RhY2tpbmdfY29udGV4dFxuICBpZiAoc3R5bGUucG9zaXRpb24gPT09IFwiZml4ZWRcIikgcmV0dXJuIHRydWU7XG4gIC8vIEZvcmtlZCB0byBmaXggdXBzdHJlYW0gYnVnIGh0dHBzOi8vZ2l0aHViLmNvbS9SaWNoLUhhcnJpcy9zdGFja2luZy1vcmRlci9pc3N1ZXMvM1xuICAvLyBpZiAoXG4gIC8vICAgKHN0eWxlLnpJbmRleCAhPT0gXCJhdXRvXCIgJiYgc3R5bGUucG9zaXRpb24gIT09IFwic3RhdGljXCIpIHx8XG4gIC8vICAgaXNfZmxleF9pdGVtKG5vZGUpXG4gIC8vIClcbiAgaWYgKHN0eWxlLnpJbmRleCAhPT0gXCJhdXRvXCIgJiYgKHN0eWxlLnBvc2l0aW9uICE9PSBcInN0YXRpY1wiIHx8IGlzX2ZsZXhfaXRlbShub2RlKSkpIHJldHVybiB0cnVlO1xuICBpZiAoK3N0eWxlLm9wYWNpdHkgPCAxKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFwidHJhbnNmb3JtXCIgaW4gc3R5bGUgJiYgc3R5bGUudHJhbnNmb3JtICE9PSBcIm5vbmVcIikgcmV0dXJuIHRydWU7XG4gIGlmIChcIndlYmtpdFRyYW5zZm9ybVwiIGluIHN0eWxlICYmIHN0eWxlLndlYmtpdFRyYW5zZm9ybSAhPT0gXCJub25lXCIpIHJldHVybiB0cnVlO1xuICBpZiAoXCJtaXhCbGVuZE1vZGVcIiBpbiBzdHlsZSAmJiBzdHlsZS5taXhCbGVuZE1vZGUgIT09IFwibm9ybWFsXCIpIHJldHVybiB0cnVlO1xuICBpZiAoXCJmaWx0ZXJcIiBpbiBzdHlsZSAmJiBzdHlsZS5maWx0ZXIgIT09IFwibm9uZVwiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFwid2Via2l0RmlsdGVyXCIgaW4gc3R5bGUgJiYgc3R5bGUud2Via2l0RmlsdGVyICE9PSBcIm5vbmVcIikgcmV0dXJuIHRydWU7XG4gIGlmIChcImlzb2xhdGlvblwiIGluIHN0eWxlICYmIHN0eWxlLmlzb2xhdGlvbiA9PT0gXCJpc29sYXRlXCIpIHJldHVybiB0cnVlO1xuICBpZiAocHJvcHMudGVzdChzdHlsZS53aWxsQ2hhbmdlKSkgcmV0dXJuIHRydWU7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgaWYgKHN0eWxlLndlYmtpdE92ZXJmbG93U2Nyb2xsaW5nID09PSBcInRvdWNoXCIpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKiBAcGFyYW0ge0hUTUxFbGVtZW50W119IG5vZGVzICovXG5mdW5jdGlvbiBmaW5kX3N0YWNraW5nX2NvbnRleHQobm9kZXMpIHtcbiAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgYXNzZXJ0KG5vZGUsIFwiTWlzc2luZyBub2RlXCIpO1xuICAgIGlmIChjcmVhdGVzX3N0YWNraW5nX2NvbnRleHQobm9kZSkpIHJldHVybiBub2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKiogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSAqL1xuZnVuY3Rpb24gZ2V0X3pfaW5kZXgobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBOdW1iZXIoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS56SW5kZXgpIHx8IDA7XG59XG5cbi8qKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlICovXG5mdW5jdGlvbiBnZXRfYW5jZXN0b3JzKG5vZGUpIHtcbiAgY29uc3QgYW5jZXN0b3JzID0gW107XG4gIHdoaWxlIChub2RlKSB7XG4gICAgYW5jZXN0b3JzLnB1c2gobm9kZSk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIG5vZGUgPSBnZXRfcGFyZW50KG5vZGUpO1xuICB9XG4gIHJldHVybiBhbmNlc3RvcnM7IC8vIFsgbm9kZSwgLi4uIDxib2R5PiwgPGh0bWw+LCBkb2N1bWVudCBdXG59XG5cbi8qKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlICovXG5mdW5jdGlvbiBnZXRfcGFyZW50KG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIHBhcmVudE5vZGVcbiAgfSA9IG5vZGU7XG4gIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgcmV0dXJuIHBhcmVudE5vZGUuaG9zdDtcbiAgfVxuICByZXR1cm4gcGFyZW50Tm9kZTtcbn1cblxuY29uc3QgRVhDRUVERURfSE9SSVpPTlRBTF9NSU4gPSAwYjAwMDE7XG5jb25zdCBFWENFRURFRF9IT1JJWk9OVEFMX01BWCA9IDBiMDAxMDtcbmNvbnN0IEVYQ0VFREVEX1ZFUlRJQ0FMX01JTiA9IDBiMDEwMDtcbmNvbnN0IEVYQ0VFREVEX1ZFUlRJQ0FMX01BWCA9IDBiMTAwMDtcbmNvbnN0IGlzQ29hcnNlUG9pbnRlciA9IGdldElucHV0VHlwZSgpID09PSBcImNvYXJzZVwiO1xubGV0IGludGVyc2VjdGluZ0hhbmRsZXMgPSBbXTtcbmxldCBpc1BvaW50ZXJEb3duID0gZmFsc2U7XG5sZXQgb3duZXJEb2N1bWVudENvdW50cyA9IG5ldyBNYXAoKTtcbmxldCBwYW5lbENvbnN0cmFpbnRGbGFncyA9IG5ldyBNYXAoKTtcbmNvbnN0IHJlZ2lzdGVyZWRSZXNpemVIYW5kbGVycyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHJlZ2lzdGVyUmVzaXplSGFuZGxlKHJlc2l6ZUhhbmRsZUlkLCBlbGVtZW50LCBkaXJlY3Rpb24sIGhpdEFyZWFNYXJnaW5zLCBzZXRSZXNpemVIYW5kbGVyU3RhdGUpIHtcbiAgdmFyIF9vd25lckRvY3VtZW50Q291bnRzJDtcbiAgY29uc3Qge1xuICAgIG93bmVyRG9jdW1lbnRcbiAgfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgZGlyZWN0aW9uLFxuICAgIGVsZW1lbnQsXG4gICAgaGl0QXJlYU1hcmdpbnMsXG4gICAgc2V0UmVzaXplSGFuZGxlclN0YXRlXG4gIH07XG4gIGNvbnN0IGNvdW50ID0gKF9vd25lckRvY3VtZW50Q291bnRzJCA9IG93bmVyRG9jdW1lbnRDb3VudHMuZ2V0KG93bmVyRG9jdW1lbnQpKSAhPT0gbnVsbCAmJiBfb3duZXJEb2N1bWVudENvdW50cyQgIT09IHZvaWQgMCA/IF9vd25lckRvY3VtZW50Q291bnRzJCA6IDA7XG4gIG93bmVyRG9jdW1lbnRDb3VudHMuc2V0KG93bmVyRG9jdW1lbnQsIGNvdW50ICsgMSk7XG4gIHJlZ2lzdGVyZWRSZXNpemVIYW5kbGVycy5hZGQoZGF0YSk7XG4gIHVwZGF0ZUxpc3RlbmVycygpO1xuICByZXR1cm4gZnVuY3Rpb24gdW5yZWdpc3RlclJlc2l6ZUhhbmRsZSgpIHtcbiAgICB2YXIgX293bmVyRG9jdW1lbnRDb3VudHMkMjtcbiAgICBwYW5lbENvbnN0cmFpbnRGbGFncy5kZWxldGUocmVzaXplSGFuZGxlSWQpO1xuICAgIHJlZ2lzdGVyZWRSZXNpemVIYW5kbGVycy5kZWxldGUoZGF0YSk7XG4gICAgY29uc3QgY291bnQgPSAoX293bmVyRG9jdW1lbnRDb3VudHMkMiA9IG93bmVyRG9jdW1lbnRDb3VudHMuZ2V0KG93bmVyRG9jdW1lbnQpKSAhPT0gbnVsbCAmJiBfb3duZXJEb2N1bWVudENvdW50cyQyICE9PSB2b2lkIDAgPyBfb3duZXJEb2N1bWVudENvdW50cyQyIDogMTtcbiAgICBvd25lckRvY3VtZW50Q291bnRzLnNldChvd25lckRvY3VtZW50LCBjb3VudCAtIDEpO1xuICAgIHVwZGF0ZUxpc3RlbmVycygpO1xuICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgb3duZXJEb2N1bWVudENvdW50cy5kZWxldGUob3duZXJEb2N1bWVudCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHJlc2l6ZSBoYW5kbGUgdGhhdCBpcyBjdXJyZW50bHkgdW5tb3VudGluZyBpcyBpbnRlcnNlY3Rpbmcgd2l0aCB0aGUgcG9pbnRlcixcbiAgICAvLyB1cGRhdGUgdGhlIGdsb2JhbCBwb2ludGVyIHRvIGFjY291bnQgZm9yIHRoZSBjaGFuZ2VcbiAgICBpZiAoaW50ZXJzZWN0aW5nSGFuZGxlcy5pbmNsdWRlcyhkYXRhKSkge1xuICAgICAgY29uc3QgaW5kZXggPSBpbnRlcnNlY3RpbmdIYW5kbGVzLmluZGV4T2YoZGF0YSk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBpbnRlcnNlY3RpbmdIYW5kbGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICB1cGRhdGVDdXJzb3IoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBoYW5kbGVQb2ludGVyRG93bihldmVudCkge1xuICBjb25zdCB7XG4gICAgdGFyZ2V0XG4gIH0gPSBldmVudDtcbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeVxuICB9ID0gZ2V0UmVzaXplRXZlbnRDb29yZGluYXRlcyhldmVudCk7XG4gIGlzUG9pbnRlckRvd24gPSB0cnVlO1xuICByZWNhbGN1bGF0ZUludGVyc2VjdGluZ0hhbmRsZXMoe1xuICAgIHRhcmdldCxcbiAgICB4LFxuICAgIHlcbiAgfSk7XG4gIHVwZGF0ZUxpc3RlbmVycygpO1xuICBpZiAoaW50ZXJzZWN0aW5nSGFuZGxlcy5sZW5ndGggPiAwKSB7XG4gICAgdXBkYXRlUmVzaXplSGFuZGxlclN0YXRlcyhcImRvd25cIiwgZXZlbnQpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJNb3ZlKGV2ZW50KSB7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IGdldFJlc2l6ZUV2ZW50Q29vcmRpbmF0ZXMoZXZlbnQpO1xuICBpZiAoIWlzUG9pbnRlckRvd24pIHtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXRcbiAgICB9ID0gZXZlbnQ7XG5cbiAgICAvLyBSZWNhbGN1bGF0ZSBpbnRlcnNlY3RpbmcgaGFuZGxlcyB3aGVuZXZlciB0aGUgcG9pbnRlciBtb3ZlcywgZXhjZXB0IGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gcHJlc3NlZFxuICAgIC8vIGF0IHRoYXQgcG9pbnQsIHRoZSBoYW5kbGVzIG1heSBub3QgbW92ZSB3aXRoIHRoZSBwb2ludGVyIChkZXBlbmRpbmcgb24gY29uc3RyYWludHMpXG4gICAgLy8gYnV0IHRoZSBzYW1lIHNldCBvZiBhY3RpdmUgaGFuZGxlcyBzaG91bGQgYmUgbG9ja2VkIHVudGlsIHRoZSBwb2ludGVyIGlzIHJlbGVhc2VkXG4gICAgcmVjYWxjdWxhdGVJbnRlcnNlY3RpbmdIYW5kbGVzKHtcbiAgICAgIHRhcmdldCxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlUmVzaXplSGFuZGxlclN0YXRlcyhcIm1vdmVcIiwgZXZlbnQpO1xuXG4gIC8vIFVwZGF0ZSBjdXJzb3IgYmFzZWQgb24gcmV0dXJuIHZhbHVlKHMpIGZyb20gYWN0aXZlIGhhbmRsZXNcbiAgdXBkYXRlQ3Vyc29yKCk7XG4gIGlmIChpbnRlcnNlY3RpbmdIYW5kbGVzLmxlbmd0aCA+IDApIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVQb2ludGVyVXAoZXZlbnQpIHtcbiAgY29uc3Qge1xuICAgIHRhcmdldFxuICB9ID0gZXZlbnQ7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IGdldFJlc2l6ZUV2ZW50Q29vcmRpbmF0ZXMoZXZlbnQpO1xuICBwYW5lbENvbnN0cmFpbnRGbGFncy5jbGVhcigpO1xuICBpc1BvaW50ZXJEb3duID0gZmFsc2U7XG4gIGlmIChpbnRlcnNlY3RpbmdIYW5kbGVzLmxlbmd0aCA+IDApIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIHVwZGF0ZVJlc2l6ZUhhbmRsZXJTdGF0ZXMoXCJ1cFwiLCBldmVudCk7XG4gIHJlY2FsY3VsYXRlSW50ZXJzZWN0aW5nSGFuZGxlcyh7XG4gICAgdGFyZ2V0LFxuICAgIHgsXG4gICAgeVxuICB9KTtcbiAgdXBkYXRlQ3Vyc29yKCk7XG4gIHVwZGF0ZUxpc3RlbmVycygpO1xufVxuZnVuY3Rpb24gcmVjYWxjdWxhdGVJbnRlcnNlY3RpbmdIYW5kbGVzKHtcbiAgdGFyZ2V0LFxuICB4LFxuICB5XG59KSB7XG4gIGludGVyc2VjdGluZ0hhbmRsZXMuc3BsaWNlKDApO1xuICBsZXQgdGFyZ2V0RWxlbWVudCA9IG51bGw7XG4gIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHRhcmdldEVsZW1lbnQgPSB0YXJnZXQ7XG4gIH1cbiAgcmVnaXN0ZXJlZFJlc2l6ZUhhbmRsZXJzLmZvckVhY2goZGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudDogZHJhZ0hhbmRsZUVsZW1lbnQsXG4gICAgICBoaXRBcmVhTWFyZ2luc1xuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IGRyYWdIYW5kbGVSZWN0ID0gZHJhZ0hhbmRsZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qge1xuICAgICAgYm90dG9tLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgdG9wXG4gICAgfSA9IGRyYWdIYW5kbGVSZWN0O1xuICAgIGNvbnN0IG1hcmdpbiA9IGlzQ29hcnNlUG9pbnRlciA/IGhpdEFyZWFNYXJnaW5zLmNvYXJzZSA6IGhpdEFyZWFNYXJnaW5zLmZpbmU7XG4gICAgY29uc3QgZXZlbnRJbnRlcnNlY3RzID0geCA+PSBsZWZ0IC0gbWFyZ2luICYmIHggPD0gcmlnaHQgKyBtYXJnaW4gJiYgeSA+PSB0b3AgLSBtYXJnaW4gJiYgeSA8PSBib3R0b20gKyBtYXJnaW47XG4gICAgaWYgKGV2ZW50SW50ZXJzZWN0cykge1xuICAgICAgLy8gVFJJQ0tZXG4gICAgICAvLyBXZSBsaXN0ZW4gZm9yIHBvaW50ZXJzIGV2ZW50cyBhdCB0aGUgcm9vdCBpbiBvcmRlciB0byBzdXBwb3J0IGhpdCBhcmVhIG1hcmdpbnNcbiAgICAgIC8vIChkZXRlcm1pbmluZyB3aGVuIHRoZSBwb2ludGVyIGlzIGNsb3NlIGVub3VnaCB0byBhbiBlbGVtZW50IHRvIGJlIGNvbnNpZGVyZWQgYSBcImhpdFwiKVxuICAgICAgLy8gQ2xpY2tpbmcgb24gYW4gZWxlbWVudCBcImFib3ZlXCIgYSBoYW5kbGUgKGUuZy4gYSBtb2RhbCkgc2hvdWxkIHByZXZlbnQgYSBoaXQgdGhvdWdoXG4gICAgICAvLyBzbyBhdCB0aGlzIHBvaW50IHdlIG5lZWQgdG8gY29tcGFyZSBzdGFja2luZyBvcmRlciBvZiBhIHBvdGVudGlhbGx5IGludGVyc2VjdGluZyBkcmFnIGhhbmRsZSxcbiAgICAgIC8vIGFuZCB0aGUgZWxlbWVudCB0aGF0IHdhcyBhY3R1YWxseSBjbGlja2VkL3RvdWNoZWRcbiAgICAgIGlmICh0YXJnZXRFbGVtZW50ICE9PSBudWxsICYmIGRyYWdIYW5kbGVFbGVtZW50ICE9PSB0YXJnZXRFbGVtZW50ICYmICFkcmFnSGFuZGxlRWxlbWVudC5jb250YWlucyh0YXJnZXRFbGVtZW50KSAmJiAhdGFyZ2V0RWxlbWVudC5jb250YWlucyhkcmFnSGFuZGxlRWxlbWVudCkgJiZcbiAgICAgIC8vIENhbGN1bGF0aW5nIHN0YWNraW5nIG9yZGVyIGhhcyBhIGNvc3QsIHNvIHdlIHNob3VsZCBhdm9pZCBpdCBpZiBwb3NzaWJsZVxuICAgICAgLy8gVGhhdCBpcyB3aHkgd2Ugb25seSBjaGVjayBwb3RlbnRpYWxseSBpbnRlcnNlY3RpbmcgaGFuZGxlcyxcbiAgICAgIC8vIGFuZCB3aHkgd2Ugc2tpcCBpZiB0aGUgZXZlbnQgdGFyZ2V0IGlzIHdpdGhpbiB0aGUgaGFuZGxlJ3MgRE9NXG4gICAgICBjb21wYXJlKHRhcmdldEVsZW1lbnQsIGRyYWdIYW5kbGVFbGVtZW50KSA+IDApIHtcbiAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhYm92ZSB0aGUgZHJhZyBoYW5kbGUsIHRoZW4gd2UgYWxzbyBuZWVkIHRvIGNvbmZpcm0gdGhleSBvdmVybGFwXG4gICAgICAgIC8vIElmIHRoZXkgYXJlIGJlc2lkZSBlYWNoIG90aGVyIChlLmcuIGEgcGFuZWwgYW5kIGl0cyBkcmFnIGhhbmRsZSkgdGhlbiB0aGUgaGFuZGxlIGlzIHN0aWxsIGludGVyYWN0aXZlXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEl0J3Mgbm90IGVub3VnaCB0byBjb21wYXJlIG9ubHkgdGhlIHRhcmdldFxuICAgICAgICAvLyBUaGUgdGFyZ2V0IG1pZ2h0IGJlIGEgc21hbGwgZWxlbWVudCBpbnNpZGUgb2YgYSBsYXJnZXIgY29udGFpbmVyXG4gICAgICAgIC8vIChGb3IgZXhhbXBsZSwgYSBTUEFOIG9yIGEgRElWIGluc2lkZSBvZiBhIGxhcmdlciBtb2RhbCBkaWFsb2cpXG4gICAgICAgIGxldCBjdXJyZW50RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XG4gICAgICAgIGxldCBkaWRJbnRlcnNlY3QgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50LmNvbnRhaW5zKGRyYWdIYW5kbGVFbGVtZW50KSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnRlcnNlY3RzKGN1cnJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBkcmFnSGFuZGxlUmVjdCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIGRpZEludGVyc2VjdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudEVsZW1lbnQgPSBjdXJyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWRJbnRlcnNlY3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGludGVyc2VjdGluZ0hhbmRsZXMucHVzaChkYXRhKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVwb3J0Q29uc3RyYWludHNWaW9sYXRpb24ocmVzaXplSGFuZGxlSWQsIGZsYWcpIHtcbiAgcGFuZWxDb25zdHJhaW50RmxhZ3Muc2V0KHJlc2l6ZUhhbmRsZUlkLCBmbGFnKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUN1cnNvcigpIHtcbiAgbGV0IGludGVyc2VjdHNIb3Jpem9udGFsID0gZmFsc2U7XG4gIGxldCBpbnRlcnNlY3RzVmVydGljYWwgPSBmYWxzZTtcbiAgaW50ZXJzZWN0aW5nSGFuZGxlcy5mb3JFYWNoKGRhdGEgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpcmVjdGlvblxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICBpbnRlcnNlY3RzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdHNWZXJ0aWNhbCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgbGV0IGNvbnN0cmFpbnRGbGFncyA9IDA7XG4gIHBhbmVsQ29uc3RyYWludEZsYWdzLmZvckVhY2goZmxhZyA9PiB7XG4gICAgY29uc3RyYWludEZsYWdzIHw9IGZsYWc7XG4gIH0pO1xuICBpZiAoaW50ZXJzZWN0c0hvcml6b250YWwgJiYgaW50ZXJzZWN0c1ZlcnRpY2FsKSB7XG4gICAgc2V0R2xvYmFsQ3Vyc29yU3R5bGUoXCJpbnRlcnNlY3Rpb25cIiwgY29uc3RyYWludEZsYWdzKTtcbiAgfSBlbHNlIGlmIChpbnRlcnNlY3RzSG9yaXpvbnRhbCkge1xuICAgIHNldEdsb2JhbEN1cnNvclN0eWxlKFwiaG9yaXpvbnRhbFwiLCBjb25zdHJhaW50RmxhZ3MpO1xuICB9IGVsc2UgaWYgKGludGVyc2VjdHNWZXJ0aWNhbCkge1xuICAgIHNldEdsb2JhbEN1cnNvclN0eWxlKFwidmVydGljYWxcIiwgY29uc3RyYWludEZsYWdzKTtcbiAgfSBlbHNlIHtcbiAgICByZXNldEdsb2JhbEN1cnNvclN0eWxlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycygpIHtcbiAgb3duZXJEb2N1bWVudENvdW50cy5mb3JFYWNoKChfLCBvd25lckRvY3VtZW50KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgYm9keVxuICAgIH0gPSBvd25lckRvY3VtZW50O1xuICAgIGJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIGhhbmRsZVBvaW50ZXJVcCk7XG4gICAgYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgIGJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCBoYW5kbGVQb2ludGVyTW92ZSk7XG4gICAgYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgaGFuZGxlUG9pbnRlck1vdmUpO1xuICB9KTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgaGFuZGxlUG9pbnRlclVwKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIGhhbmRsZVBvaW50ZXJVcCk7XG4gIGlmIChyZWdpc3RlcmVkUmVzaXplSGFuZGxlcnMuc2l6ZSA+IDApIHtcbiAgICBpZiAoaXNQb2ludGVyRG93bikge1xuICAgICAgaWYgKGludGVyc2VjdGluZ0hhbmRsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBvd25lckRvY3VtZW50Q291bnRzLmZvckVhY2goKGNvdW50LCBvd25lckRvY3VtZW50KSA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYm9keVxuICAgICAgICAgIH0gPSBvd25lckRvY3VtZW50O1xuICAgICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIGhhbmRsZVBvaW50ZXJVcCk7XG4gICAgICAgICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgaGFuZGxlUG9pbnRlck1vdmUpO1xuICAgICAgICAgICAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgaGFuZGxlUG9pbnRlck1vdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBoYW5kbGVQb2ludGVyVXApO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIGhhbmRsZVBvaW50ZXJVcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bmVyRG9jdW1lbnRDb3VudHMuZm9yRWFjaCgoY291bnQsIG93bmVyRG9jdW1lbnQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGJvZHlcbiAgICAgICAgfSA9IG93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBoYW5kbGVQb2ludGVyRG93biwge1xuICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVSZXNpemVIYW5kbGVyU3RhdGVzKGFjdGlvbiwgZXZlbnQpIHtcbiAgcmVnaXN0ZXJlZFJlc2l6ZUhhbmRsZXJzLmZvckVhY2goZGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgc2V0UmVzaXplSGFuZGxlclN0YXRlXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgaXNBY3RpdmUgPSBpbnRlcnNlY3RpbmdIYW5kbGVzLmluY2x1ZGVzKGRhdGEpO1xuICAgIHNldFJlc2l6ZUhhbmRsZXJTdGF0ZShhY3Rpb24sIGlzQWN0aXZlLCBldmVudCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhc3NlcnQoZXhwZWN0ZWRDb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFleHBlY3RlZENvbmRpdGlvbikge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgdGhyb3cgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuY29uc3QgUFJFQ0lTSU9OID0gMTA7XG5cbmZ1bmN0aW9uIGZ1enp5Q29tcGFyZU51bWJlcnMoYWN0dWFsLCBleHBlY3RlZCwgZnJhY3Rpb25EaWdpdHMgPSBQUkVDSVNJT04pIHtcbiAgaWYgKGFjdHVhbC50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSA9PT0gZXhwZWN0ZWQudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYWN0dWFsID4gZXhwZWN0ZWQgPyAxIDogLTE7XG4gIH1cbn1cbmZ1bmN0aW9uIGZ1enp5TnVtYmVyc0VxdWFsJDEoYWN0dWFsLCBleHBlY3RlZCwgZnJhY3Rpb25EaWdpdHMgPSBQUkVDSVNJT04pIHtcbiAgcmV0dXJuIGZ1enp5Q29tcGFyZU51bWJlcnMoYWN0dWFsLCBleHBlY3RlZCwgZnJhY3Rpb25EaWdpdHMpID09PSAwO1xufVxuXG5mdW5jdGlvbiBmdXp6eU51bWJlcnNFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmcmFjdGlvbkRpZ2l0cykge1xuICByZXR1cm4gZnV6enlDb21wYXJlTnVtYmVycyhhY3R1YWwsIGV4cGVjdGVkLCBmcmFjdGlvbkRpZ2l0cykgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGZ1enp5TGF5b3V0c0VxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZyYWN0aW9uRGlnaXRzKSB7XG4gIGlmIChhY3R1YWwubGVuZ3RoICE9PSBleHBlY3RlZC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFjdHVhbC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBhY3R1YWxTaXplID0gYWN0dWFsW2luZGV4XTtcbiAgICBjb25zdCBleHBlY3RlZFNpemUgPSBleHBlY3RlZFtpbmRleF07XG4gICAgaWYgKCFmdXp6eU51bWJlcnNFcXVhbChhY3R1YWxTaXplLCBleHBlY3RlZFNpemUsIGZyYWN0aW9uRGlnaXRzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gUGFuZWwgc2l6ZSBtdXN0IGJlIGluIHBlcmNlbnRhZ2VzOyBwaXhlbCB2YWx1ZXMgc2hvdWxkIGJlIHByZS1jb252ZXJ0ZWRcbmZ1bmN0aW9uIHJlc2l6ZVBhbmVsKHtcbiAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICBwYW5lbEluZGV4LFxuICBzaXplXG59KSB7XG4gIGNvbnN0IHBhbmVsQ29uc3RyYWludHMgPSBwYW5lbENvbnN0cmFpbnRzQXJyYXlbcGFuZWxJbmRleF07XG4gIGFzc2VydChwYW5lbENvbnN0cmFpbnRzICE9IG51bGwsIGBQYW5lbCBjb25zdHJhaW50cyBub3QgZm91bmQgZm9yIGluZGV4ICR7cGFuZWxJbmRleH1gKTtcbiAgbGV0IHtcbiAgICBjb2xsYXBzZWRTaXplID0gMCxcbiAgICBjb2xsYXBzaWJsZSxcbiAgICBtYXhTaXplID0gMTAwLFxuICAgIG1pblNpemUgPSAwXG4gIH0gPSBwYW5lbENvbnN0cmFpbnRzO1xuICBpZiAoZnV6enlDb21wYXJlTnVtYmVycyhzaXplLCBtaW5TaXplKSA8IDApIHtcbiAgICBpZiAoY29sbGFwc2libGUpIHtcbiAgICAgIC8vIENvbGxhcHNpYmxlIHBhbmVscyBzaG91bGQgc25hcCBjbG9zZWQgb3Igb3BlbiBvbmx5IG9uY2UgdGhleSBjcm9zcyB0aGUgaGFsZndheSBwb2ludCBiZXR3ZWVuIGNvbGxhcHNlZCBhbmQgbWluIHNpemUuXG4gICAgICBjb25zdCBoYWxmd2F5UG9pbnQgPSAoY29sbGFwc2VkU2l6ZSArIG1pblNpemUpIC8gMjtcbiAgICAgIGlmIChmdXp6eUNvbXBhcmVOdW1iZXJzKHNpemUsIGhhbGZ3YXlQb2ludCkgPCAwKSB7XG4gICAgICAgIHNpemUgPSBjb2xsYXBzZWRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IG1pblNpemU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSBtaW5TaXplO1xuICAgIH1cbiAgfVxuICBzaXplID0gTWF0aC5taW4obWF4U2l6ZSwgc2l6ZSk7XG4gIHNpemUgPSBwYXJzZUZsb2F0KHNpemUudG9GaXhlZChQUkVDSVNJT04pKTtcbiAgcmV0dXJuIHNpemU7XG59XG5cbi8vIEFsbCB1bml0cyBtdXN0IGJlIGluIHBlcmNlbnRhZ2VzOyBwaXhlbCB2YWx1ZXMgc2hvdWxkIGJlIHByZS1jb252ZXJ0ZWRcbmZ1bmN0aW9uIGFkanVzdExheW91dEJ5RGVsdGEoe1xuICBkZWx0YSxcbiAgaW5pdGlhbExheW91dCxcbiAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICBwaXZvdEluZGljZXMsXG4gIHByZXZMYXlvdXQsXG4gIHRyaWdnZXJcbn0pIHtcbiAgaWYgKGZ1enp5TnVtYmVyc0VxdWFsKGRlbHRhLCAwKSkge1xuICAgIHJldHVybiBpbml0aWFsTGF5b3V0O1xuICB9XG4gIGNvbnN0IG5leHRMYXlvdXQgPSBbLi4uaW5pdGlhbExheW91dF07XG4gIGNvbnN0IFtmaXJzdFBpdm90SW5kZXgsIHNlY29uZFBpdm90SW5kZXhdID0gcGl2b3RJbmRpY2VzO1xuICBhc3NlcnQoZmlyc3RQaXZvdEluZGV4ICE9IG51bGwsIFwiSW52YWxpZCBmaXJzdCBwaXZvdCBpbmRleFwiKTtcbiAgYXNzZXJ0KHNlY29uZFBpdm90SW5kZXggIT0gbnVsbCwgXCJJbnZhbGlkIHNlY29uZCBwaXZvdCBpbmRleFwiKTtcbiAgbGV0IGRlbHRhQXBwbGllZCA9IDA7XG5cbiAgLy8gY29uc3QgREVCVUcgPSBbXTtcbiAgLy8gREVCVUcucHVzaChgYWRqdXN0TGF5b3V0QnlEZWx0YSgpYCk7XG4gIC8vIERFQlVHLnB1c2goYCAgaW5pdGlhbExheW91dDogJHtpbml0aWFsTGF5b3V0LmpvaW4oXCIsIFwiKX1gKTtcbiAgLy8gREVCVUcucHVzaChgICBwcmV2TGF5b3V0OiAke3ByZXZMYXlvdXQuam9pbihcIiwgXCIpfWApO1xuICAvLyBERUJVRy5wdXNoKGAgIGRlbHRhOiAke2RlbHRhfWApO1xuICAvLyBERUJVRy5wdXNoKGAgIHBpdm90SW5kaWNlczogJHtwaXZvdEluZGljZXMuam9pbihcIiwgXCIpfWApO1xuICAvLyBERUJVRy5wdXNoKGAgIHRyaWdnZXI6ICR7dHJpZ2dlcn1gKTtcbiAgLy8gREVCVUcucHVzaChcIlwiKTtcblxuICAvLyBBIHJlc2l6aW5nIHBhbmVsIGFmZmVjdHMgdGhlIHBhbmVscyBiZWZvcmUgb3IgYWZ0ZXIgaXQuXG4gIC8vXG4gIC8vIEEgbmVnYXRpdmUgZGVsdGEgbWVhbnMgdGhlIHBhbmVsKHMpIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSByZXNpemUgaGFuZGxlIHNob3VsZCBncm93L2V4cGFuZCBieSBkZWNyZWFzaW5nIGl0cyBvZmZzZXQuXG4gIC8vIE90aGVyIHBhbmVscyBtYXkgYWxzbyBuZWVkIHRvIHNocmluay9jb250cmFjdCAoYW5kIHNoaWZ0KSB0byBtYWtlIHJvb20sIGRlcGVuZGluZyBvbiB0aGUgbWluIHdlaWdodHMuXG4gIC8vXG4gIC8vIEEgcG9zaXRpdmUgZGVsdGEgbWVhbnMgdGhlIHBhbmVsKHMpIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgcmVzaXplIGhhbmRsZSBzaG91bGQgXCJleHBhbmRcIi5cbiAgLy8gVGhpcyBpcyBhY2NvbXBsaXNoZWQgYnkgc2hyaW5raW5nL2NvbnRyYWN0aW5nIChhbmQgc2hpZnRpbmcpIG9uZSBvciBtb3JlIG9mIHRoZSBwYW5lbHMgYWZ0ZXIgdGhlIHJlc2l6ZSBoYW5kbGUuXG5cbiAge1xuICAgIC8vIElmIHRoaXMgaXMgYSByZXNpemUgdHJpZ2dlcmVkIGJ5IGEga2V5Ym9hcmQgZXZlbnQsIG91ciBsb2dpYyBmb3IgZXhwYW5kaW5nL2NvbGxhcHNpbmcgaXMgZGlmZmVyZW50LlxuICAgIC8vIFdlIG5vIGxvbmdlciBjaGVjayB0aGUgaGFsZndheSB0aHJlc2hvbGQgYmVjYXVzZSB0aGlzIG1heSBwcmV2ZW50IHRoZSBwYW5lbCBmcm9tIGV4cGFuZGluZyBhdCBhbGwuXG4gICAgaWYgKHRyaWdnZXIgPT09IFwia2V5Ym9hcmRcIikge1xuICAgICAge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgZXhwYW5kIGEgY29sbGFwc2VkIHBhbmVsXG4gICAgICAgIGNvbnN0IGluZGV4ID0gZGVsdGEgPCAwID8gc2Vjb25kUGl2b3RJbmRleCA6IGZpcnN0UGl2b3RJbmRleDtcbiAgICAgICAgY29uc3QgcGFuZWxDb25zdHJhaW50cyA9IHBhbmVsQ29uc3RyYWludHNBcnJheVtpbmRleF07XG4gICAgICAgIGFzc2VydChwYW5lbENvbnN0cmFpbnRzLCBgUGFuZWwgY29uc3RyYWludHMgbm90IGZvdW5kIGZvciBpbmRleCAke2luZGV4fWApO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICAgICAgY29sbGFwc2libGUsXG4gICAgICAgICAgbWluU2l6ZSA9IDBcbiAgICAgICAgfSA9IHBhbmVsQ29uc3RyYWludHM7XG5cbiAgICAgICAgLy8gREVCVUcucHVzaChgZWRnZSBjYXNlIGNoZWNrIDE6ICR7aW5kZXh9YCk7XG4gICAgICAgIC8vIERFQlVHLnB1c2goYCAgLT4gY29sbGFwc2libGU/ICR7Y29sbGFwc2libGV9YCk7XG4gICAgICAgIGlmIChjb2xsYXBzaWJsZSkge1xuICAgICAgICAgIGNvbnN0IHByZXZTaXplID0gaW5pdGlhbExheW91dFtpbmRleF07XG4gICAgICAgICAgYXNzZXJ0KHByZXZTaXplICE9IG51bGwsIGBQcmV2aW91cyBsYXlvdXQgbm90IGZvdW5kIGZvciBwYW5lbCBpbmRleCAke2luZGV4fWApO1xuICAgICAgICAgIGlmIChmdXp6eU51bWJlcnNFcXVhbChwcmV2U2l6ZSwgY29sbGFwc2VkU2l6ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsRGVsdGEgPSBtaW5TaXplIC0gcHJldlNpemU7XG4gICAgICAgICAgICAvLyBERUJVRy5wdXNoKGAgIC0+IGV4cGFuZCBkZWx0YTogJHtsb2NhbERlbHRhfWApO1xuXG4gICAgICAgICAgICBpZiAoZnV6enlDb21wYXJlTnVtYmVycyhsb2NhbERlbHRhLCBNYXRoLmFicyhkZWx0YSkpID4gMCkge1xuICAgICAgICAgICAgICBkZWx0YSA9IGRlbHRhIDwgMCA/IDAgLSBsb2NhbERlbHRhIDogbG9jYWxEZWx0YTtcbiAgICAgICAgICAgICAgLy8gREVCVUcucHVzaChgICAtPiBkZWx0YTogJHtkZWx0YX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgY29sbGFwc2UgYSBwYW5lbCBhdCBpdHMgbWluaW11bSBzaXplXG4gICAgICAgIGNvbnN0IGluZGV4ID0gZGVsdGEgPCAwID8gZmlyc3RQaXZvdEluZGV4IDogc2Vjb25kUGl2b3RJbmRleDtcbiAgICAgICAgY29uc3QgcGFuZWxDb25zdHJhaW50cyA9IHBhbmVsQ29uc3RyYWludHNBcnJheVtpbmRleF07XG4gICAgICAgIGFzc2VydChwYW5lbENvbnN0cmFpbnRzLCBgTm8gcGFuZWwgY29uc3RyYWludHMgZm91bmQgZm9yIGluZGV4ICR7aW5kZXh9YCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjb2xsYXBzZWRTaXplID0gMCxcbiAgICAgICAgICBjb2xsYXBzaWJsZSxcbiAgICAgICAgICBtaW5TaXplID0gMFxuICAgICAgICB9ID0gcGFuZWxDb25zdHJhaW50cztcblxuICAgICAgICAvLyBERUJVRy5wdXNoKGBlZGdlIGNhc2UgY2hlY2sgMjogJHtpbmRleH1gKTtcbiAgICAgICAgLy8gREVCVUcucHVzaChgICAtPiBjb2xsYXBzaWJsZT8gJHtjb2xsYXBzaWJsZX1gKTtcbiAgICAgICAgaWYgKGNvbGxhcHNpYmxlKSB7XG4gICAgICAgICAgY29uc3QgcHJldlNpemUgPSBpbml0aWFsTGF5b3V0W2luZGV4XTtcbiAgICAgICAgICBhc3NlcnQocHJldlNpemUgIT0gbnVsbCwgYFByZXZpb3VzIGxheW91dCBub3QgZm91bmQgZm9yIHBhbmVsIGluZGV4ICR7aW5kZXh9YCk7XG4gICAgICAgICAgaWYgKGZ1enp5TnVtYmVyc0VxdWFsKHByZXZTaXplLCBtaW5TaXplKSkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxEZWx0YSA9IHByZXZTaXplIC0gY29sbGFwc2VkU2l6ZTtcbiAgICAgICAgICAgIC8vIERFQlVHLnB1c2goYCAgLT4gZXhwYW5kIGRlbHRhOiAke2xvY2FsRGVsdGF9YCk7XG5cbiAgICAgICAgICAgIGlmIChmdXp6eUNvbXBhcmVOdW1iZXJzKGxvY2FsRGVsdGEsIE1hdGguYWJzKGRlbHRhKSkgPiAwKSB7XG4gICAgICAgICAgICAgIGRlbHRhID0gZGVsdGEgPCAwID8gMCAtIGxvY2FsRGVsdGEgOiBsb2NhbERlbHRhO1xuICAgICAgICAgICAgICAvLyBERUJVRy5wdXNoKGAgIC0+IGRlbHRhOiAke2RlbHRhfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBERUJVRy5wdXNoKFwiXCIpO1xuICB9XG5cbiAge1xuICAgIC8vIFByZS1jYWxjdWxhdGUgbWF4IGF2YWlsYWJsZSBkZWx0YSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIG9mIG91ciBwaXZvdC5cbiAgICAvLyBUaGlzIHdpbGwgYmUgdGhlIG1heGltdW0gYW1vdW50IHdlJ3JlIGFsbG93ZWQgdG8gZXhwYW5kL2NvbnRyYWN0IHRoZSBwYW5lbHMgaW4gdGhlIHByaW1hcnkgZGlyZWN0aW9uLlxuICAgIC8vIElmIHRoaXMgYW1vdW50IGlzIGxlc3MgdGhhbiB0aGUgcmVxdWVzdGVkIGRlbHRhLCBhZGp1c3QgdGhlIHJlcXVlc3RlZCBkZWx0YS5cbiAgICAvLyBJZiB0aGlzIGFtb3VudCBpcyBncmVhdGVyIHRoYW4gdGhlIHJlcXVlc3RlZCBkZWx0YSwgdGhhdCdzIHVzZWZ1bCBpbmZvcm1hdGlvbiB0b2/igJNcbiAgICAvLyBhcyBhbiBleHBhbmRpbmcgcGFuZWwgbWlnaHQgY2hhbmdlIGZyb20gY29sbGFwc2VkIHRvIG1pbiBzaXplLlxuXG4gICAgY29uc3QgaW5jcmVtZW50ID0gZGVsdGEgPCAwID8gMSA6IC0xO1xuICAgIGxldCBpbmRleCA9IGRlbHRhIDwgMCA/IHNlY29uZFBpdm90SW5kZXggOiBmaXJzdFBpdm90SW5kZXg7XG4gICAgbGV0IG1heEF2YWlsYWJsZURlbHRhID0gMDtcblxuICAgIC8vIERFQlVHLnB1c2goXCJwcmUgY2FsYy4uLlwiKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgcHJldlNpemUgPSBpbml0aWFsTGF5b3V0W2luZGV4XTtcbiAgICAgIGFzc2VydChwcmV2U2l6ZSAhPSBudWxsLCBgUHJldmlvdXMgbGF5b3V0IG5vdCBmb3VuZCBmb3IgcGFuZWwgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgIGNvbnN0IG1heFNhZmVTaXplID0gcmVzaXplUGFuZWwoe1xuICAgICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gICAgICAgIHBhbmVsSW5kZXg6IGluZGV4LFxuICAgICAgICBzaXplOiAxMDBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGVsdGEgPSBtYXhTYWZlU2l6ZSAtIHByZXZTaXplO1xuICAgICAgLy8gREVCVUcucHVzaChgICAke2luZGV4fTogJHtwcmV2U2l6ZX0gLT4gJHttYXhTYWZlU2l6ZX1gKTtcblxuICAgICAgbWF4QXZhaWxhYmxlRGVsdGEgKz0gZGVsdGE7XG4gICAgICBpbmRleCArPSBpbmNyZW1lbnQ7XG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHBhbmVsQ29uc3RyYWludHNBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gREVCVUcucHVzaChgICAtPiBtYXggYXZhaWxhYmxlIGRlbHRhOiAke21heEF2YWlsYWJsZURlbHRhfWApO1xuICAgIGNvbnN0IG1pbkFic0RlbHRhID0gTWF0aC5taW4oTWF0aC5hYnMoZGVsdGEpLCBNYXRoLmFicyhtYXhBdmFpbGFibGVEZWx0YSkpO1xuICAgIGRlbHRhID0gZGVsdGEgPCAwID8gMCAtIG1pbkFic0RlbHRhIDogbWluQWJzRGVsdGE7XG4gICAgLy8gREVCVUcucHVzaChgICAtPiBhZGp1c3RlZCBkZWx0YTogJHtkZWx0YX1gKTtcbiAgICAvLyBERUJVRy5wdXNoKFwiXCIpO1xuICB9XG5cbiAge1xuICAgIC8vIERlbHRhIGFkZGVkIHRvIGEgcGFuZWwgbmVlZHMgdG8gYmUgc3VidHJhY3RlZCBmcm9tIG90aGVyIHBhbmVscyAod2l0aGluIHRoZSBjb25zdHJhaW50cyB0aGF0IHRob3NlIHBhbmVscyBhbGxvdykuXG5cbiAgICBjb25zdCBwaXZvdEluZGV4ID0gZGVsdGEgPCAwID8gZmlyc3RQaXZvdEluZGV4IDogc2Vjb25kUGl2b3RJbmRleDtcbiAgICBsZXQgaW5kZXggPSBwaXZvdEluZGV4O1xuICAgIHdoaWxlIChpbmRleCA+PSAwICYmIGluZGV4IDwgcGFuZWxDb25zdHJhaW50c0FycmF5Lmxlbmd0aCkge1xuICAgICAgY29uc3QgZGVsdGFSZW1haW5pbmcgPSBNYXRoLmFicyhkZWx0YSkgLSBNYXRoLmFicyhkZWx0YUFwcGxpZWQpO1xuICAgICAgY29uc3QgcHJldlNpemUgPSBpbml0aWFsTGF5b3V0W2luZGV4XTtcbiAgICAgIGFzc2VydChwcmV2U2l6ZSAhPSBudWxsLCBgUHJldmlvdXMgbGF5b3V0IG5vdCBmb3VuZCBmb3IgcGFuZWwgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgIGNvbnN0IHVuc2FmZVNpemUgPSBwcmV2U2l6ZSAtIGRlbHRhUmVtYWluaW5nO1xuICAgICAgY29uc3Qgc2FmZVNpemUgPSByZXNpemVQYW5lbCh7XG4gICAgICAgIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgICAgICAgcGFuZWxJbmRleDogaW5kZXgsXG4gICAgICAgIHNpemU6IHVuc2FmZVNpemVcbiAgICAgIH0pO1xuICAgICAgaWYgKCFmdXp6eU51bWJlcnNFcXVhbChwcmV2U2l6ZSwgc2FmZVNpemUpKSB7XG4gICAgICAgIGRlbHRhQXBwbGllZCArPSBwcmV2U2l6ZSAtIHNhZmVTaXplO1xuICAgICAgICBuZXh0TGF5b3V0W2luZGV4XSA9IHNhZmVTaXplO1xuICAgICAgICBpZiAoZGVsdGFBcHBsaWVkLnRvUHJlY2lzaW9uKDMpLmxvY2FsZUNvbXBhcmUoTWF0aC5hYnMoZGVsdGEpLnRvUHJlY2lzaW9uKDMpLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICBudW1lcmljOiB0cnVlXG4gICAgICAgIH0pID49IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gREVCVUcucHVzaChgYWZ0ZXIgMTogJHtuZXh0TGF5b3V0LmpvaW4oXCIsIFwiKX1gKTtcbiAgLy8gREVCVUcucHVzaChgICBkZWx0YUFwcGxpZWQ6ICR7ZGVsdGFBcHBsaWVkfWApO1xuICAvLyBERUJVRy5wdXNoKFwiXCIpO1xuXG4gIC8vIElmIHdlIHdlcmUgdW5hYmxlIHRvIHJlc2l6ZSBhbnkgb2YgdGhlIHBhbmVscyBwYW5lbHMsIHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuXG4gIC8vIFRoaXMgd2lsbCBlc3NlbnRpYWxseSBiYWlsb3V0IGFuZCBpZ25vcmUgZS5nLiBkcmFncyBwYXN0IGEgcGFuZWwncyBib3VuZGFyaWVzXG4gIGlmIChmdXp6eUxheW91dHNFcXVhbChwcmV2TGF5b3V0LCBuZXh0TGF5b3V0KSkge1xuICAgIC8vIERFQlVHLnB1c2goYGJhaWxvdXQgdG8gcHJldmlvdXMgbGF5b3V0OiAke3ByZXZMYXlvdXQuam9pbihcIiwgXCIpfWApO1xuICAgIC8vIGNvbnNvbGUubG9nKERFQlVHLmpvaW4oXCJcXG5cIikpO1xuXG4gICAgcmV0dXJuIHByZXZMYXlvdXQ7XG4gIH1cbiAge1xuICAgIC8vIE5vdyBkaXN0cmlidXRlIHRoZSBhcHBsaWVkIGRlbHRhIHRvIHRoZSBwYW5lbHMgaW4gdGhlIG90aGVyIGRpcmVjdGlvblxuICAgIGNvbnN0IHBpdm90SW5kZXggPSBkZWx0YSA8IDAgPyBzZWNvbmRQaXZvdEluZGV4IDogZmlyc3RQaXZvdEluZGV4O1xuICAgIGNvbnN0IHByZXZTaXplID0gaW5pdGlhbExheW91dFtwaXZvdEluZGV4XTtcbiAgICBhc3NlcnQocHJldlNpemUgIT0gbnVsbCwgYFByZXZpb3VzIGxheW91dCBub3QgZm91bmQgZm9yIHBhbmVsIGluZGV4ICR7cGl2b3RJbmRleH1gKTtcbiAgICBjb25zdCB1bnNhZmVTaXplID0gcHJldlNpemUgKyBkZWx0YUFwcGxpZWQ7XG4gICAgY29uc3Qgc2FmZVNpemUgPSByZXNpemVQYW5lbCh7XG4gICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gICAgICBwYW5lbEluZGV4OiBwaXZvdEluZGV4LFxuICAgICAgc2l6ZTogdW5zYWZlU2l6ZVxuICAgIH0pO1xuXG4gICAgLy8gQWRqdXN0IHRoZSBwaXZvdCBwYW5lbCBiZWZvcmUsIGJ1dCBvbmx5IGJ5IHRoZSBhbW91bnQgdGhhdCBzdXJyb3VuZGluZyBwYW5lbHMgd2VyZSBhYmxlIHRvIHNocmluay9jb250cmFjdC5cbiAgICBuZXh0TGF5b3V0W3Bpdm90SW5kZXhdID0gc2FmZVNpemU7XG5cbiAgICAvLyBFZGdlIGNhc2Ugd2hlcmUgZXhwYW5kaW5nIG9yIGNvbnRyYWN0aW5nIG9uZSBwYW5lbCBjYXVzZWQgYW5vdGhlciBvbmUgdG8gY2hhbmdlIGNvbGxhcHNlZCBzdGF0ZVxuICAgIGlmICghZnV6enlOdW1iZXJzRXF1YWwoc2FmZVNpemUsIHVuc2FmZVNpemUpKSB7XG4gICAgICBsZXQgZGVsdGFSZW1haW5pbmcgPSB1bnNhZmVTaXplIC0gc2FmZVNpemU7XG4gICAgICBjb25zdCBwaXZvdEluZGV4ID0gZGVsdGEgPCAwID8gc2Vjb25kUGl2b3RJbmRleCA6IGZpcnN0UGl2b3RJbmRleDtcbiAgICAgIGxldCBpbmRleCA9IHBpdm90SW5kZXg7XG4gICAgICB3aGlsZSAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHBhbmVsQ29uc3RyYWludHNBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcHJldlNpemUgPSBuZXh0TGF5b3V0W2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KHByZXZTaXplICE9IG51bGwsIGBQcmV2aW91cyBsYXlvdXQgbm90IGZvdW5kIGZvciBwYW5lbCBpbmRleCAke2luZGV4fWApO1xuICAgICAgICBjb25zdCB1bnNhZmVTaXplID0gcHJldlNpemUgKyBkZWx0YVJlbWFpbmluZztcbiAgICAgICAgY29uc3Qgc2FmZVNpemUgPSByZXNpemVQYW5lbCh7XG4gICAgICAgICAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICAgICAgICAgIHBhbmVsSW5kZXg6IGluZGV4LFxuICAgICAgICAgIHNpemU6IHVuc2FmZVNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZnV6enlOdW1iZXJzRXF1YWwocHJldlNpemUsIHNhZmVTaXplKSkge1xuICAgICAgICAgIGRlbHRhUmVtYWluaW5nIC09IHNhZmVTaXplIC0gcHJldlNpemU7XG4gICAgICAgICAgbmV4dExheW91dFtpbmRleF0gPSBzYWZlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnV6enlOdW1iZXJzRXF1YWwoZGVsdGFSZW1haW5pbmcsIDApKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgIGluZGV4LS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBERUJVRy5wdXNoKGBhZnRlciAyOiAke25leHRMYXlvdXQuam9pbihcIiwgXCIpfWApO1xuICAvLyBERUJVRy5wdXNoKGAgIGRlbHRhQXBwbGllZDogJHtkZWx0YUFwcGxpZWR9YCk7XG4gIC8vIERFQlVHLnB1c2goXCJcIik7XG5cbiAgY29uc3QgdG90YWxTaXplID0gbmV4dExheW91dC5yZWR1Y2UoKHRvdGFsLCBzaXplKSA9PiBzaXplICsgdG90YWwsIDApO1xuICAvLyBERUJVRy5wdXNoKGB0b3RhbCBzaXplOiAke3RvdGFsU2l6ZX1gKTtcblxuICAvLyBJZiBvdXIgbmV3IGxheW91dCBkb2Vzbid0IGFkZCB1cCB0byAxMDAlLCB0aGF0IG1lYW5zIHRoZSByZXF1ZXN0ZWQgZGVsdGEgY2FuJ3QgYmUgYXBwbGllZFxuICAvLyBJbiB0aGF0IGNhc2UsIGZhbGwgYmFjayB0byBvdXIgbW9zdCByZWNlbnQgdmFsaWQgbGF5b3V0XG4gIGlmICghZnV6enlOdW1iZXJzRXF1YWwodG90YWxTaXplLCAxMDApKSB7XG4gICAgLy8gREVCVUcucHVzaChgYmFpbG91dCB0byBwcmV2aW91cyBsYXlvdXQ6ICR7cHJldkxheW91dC5qb2luKFwiLCBcIil9YCk7XG4gICAgLy8gY29uc29sZS5sb2coREVCVUcuam9pbihcIlxcblwiKSk7XG5cbiAgICByZXR1cm4gcHJldkxheW91dDtcbiAgfVxuXG4gIC8vIGNvbnNvbGUubG9nKERFQlVHLmpvaW4oXCJcXG5cIikpO1xuICByZXR1cm4gbmV4dExheW91dDtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzaXplSGFuZGxlRWxlbWVudHNGb3JHcm91cChncm91cElkLCBzY29wZSA9IGRvY3VtZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHNjb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWRdW2RhdGEtcGFuZWwtZ3JvdXAtaWQ9XCIke2dyb3VwSWR9XCJdYCkpO1xufVxuXG5mdW5jdGlvbiBnZXRSZXNpemVIYW5kbGVFbGVtZW50SW5kZXgoZ3JvdXBJZCwgaWQsIHNjb3BlID0gZG9jdW1lbnQpIHtcbiAgY29uc3QgaGFuZGxlcyA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRzRm9yR3JvdXAoZ3JvdXBJZCwgc2NvcGUpO1xuICBjb25zdCBpbmRleCA9IGhhbmRsZXMuZmluZEluZGV4KGhhbmRsZSA9PiBoYW5kbGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYW5lbC1yZXNpemUtaGFuZGxlLWlkXCIpID09PSBpZCk7XG4gIHJldHVybiBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCAhPT0gdm9pZCAwID8gaW5kZXggOiBudWxsO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVQaXZvdEluZGljZXMoZ3JvdXBJZCwgZHJhZ0hhbmRsZUlkLCBwYW5lbEdyb3VwRWxlbWVudCkge1xuICBjb25zdCBpbmRleCA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRJbmRleChncm91cElkLCBkcmFnSGFuZGxlSWQsIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgcmV0dXJuIGluZGV4ICE9IG51bGwgPyBbaW5kZXgsIGluZGV4ICsgMV0gOiBbLTEsIC0xXTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFuZWxHcm91cEVsZW1lbnQoaWQsIHJvb3RFbGVtZW50ID0gZG9jdW1lbnQpIHtcbiAgdmFyIF9kYXRhc2V0O1xuICAvL0lmIHRoZSByb290IGVsZW1lbnQgaXMgdGhlIFBhbmVsR3JvdXBcbiAgaWYgKHJvb3RFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgKHJvb3RFbGVtZW50ID09PSBudWxsIHx8IHJvb3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2RhdGFzZXQgPSByb290RWxlbWVudC5kYXRhc2V0KSA9PT0gbnVsbCB8fCBfZGF0YXNldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RhdGFzZXQucGFuZWxHcm91cElkKSA9PSBpZCkge1xuICAgIHJldHVybiByb290RWxlbWVudDtcbiAgfVxuXG4gIC8vRWxzZSBxdWVyeSBjaGlsZHJlblxuICBjb25zdCBlbGVtZW50ID0gcm9vdEVsZW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtcGFuZWwtZ3JvdXBdW2RhdGEtcGFuZWwtZ3JvdXAtaWQ9XCIke2lkfVwiXWApO1xuICBpZiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRSZXNpemVIYW5kbGVFbGVtZW50KGlkLCBzY29wZSA9IGRvY3VtZW50KSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBzY29wZS5xdWVyeVNlbGVjdG9yKGBbZGF0YS1wYW5lbC1yZXNpemUtaGFuZGxlLWlkPVwiJHtpZH1cIl1gKTtcbiAgaWYgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzaXplSGFuZGxlUGFuZWxJZHMoZ3JvdXBJZCwgaGFuZGxlSWQsIHBhbmVsc0FycmF5LCBzY29wZSA9IGRvY3VtZW50KSB7XG4gIHZhciBfcGFuZWxzQXJyYXkkaW5kZXgkaWQsIF9wYW5lbHNBcnJheSRpbmRleCwgX3BhbmVsc0FycmF5JGlkLCBfcGFuZWxzQXJyYXk7XG4gIGNvbnN0IGhhbmRsZSA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnQoaGFuZGxlSWQsIHNjb3BlKTtcbiAgY29uc3QgaGFuZGxlcyA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRzRm9yR3JvdXAoZ3JvdXBJZCwgc2NvcGUpO1xuICBjb25zdCBpbmRleCA9IGhhbmRsZSA/IGhhbmRsZXMuaW5kZXhPZihoYW5kbGUpIDogLTE7XG4gIGNvbnN0IGlkQmVmb3JlID0gKF9wYW5lbHNBcnJheSRpbmRleCRpZCA9IChfcGFuZWxzQXJyYXkkaW5kZXggPSBwYW5lbHNBcnJheVtpbmRleF0pID09PSBudWxsIHx8IF9wYW5lbHNBcnJheSRpbmRleCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BhbmVsc0FycmF5JGluZGV4LmlkKSAhPT0gbnVsbCAmJiBfcGFuZWxzQXJyYXkkaW5kZXgkaWQgIT09IHZvaWQgMCA/IF9wYW5lbHNBcnJheSRpbmRleCRpZCA6IG51bGw7XG4gIGNvbnN0IGlkQWZ0ZXIgPSAoX3BhbmVsc0FycmF5JGlkID0gKF9wYW5lbHNBcnJheSA9IHBhbmVsc0FycmF5W2luZGV4ICsgMV0pID09PSBudWxsIHx8IF9wYW5lbHNBcnJheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BhbmVsc0FycmF5LmlkKSAhPT0gbnVsbCAmJiBfcGFuZWxzQXJyYXkkaWQgIT09IHZvaWQgMCA/IF9wYW5lbHNBcnJheSRpZCA6IG51bGw7XG4gIHJldHVybiBbaWRCZWZvcmUsIGlkQWZ0ZXJdO1xufVxuXG4vLyBodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL3dpbmRvd3NwbGl0dGVyL1xuXG5mdW5jdGlvbiB1c2VXaW5kb3dTcGxpdHRlclBhbmVsR3JvdXBCZWhhdmlvcih7XG4gIGNvbW1pdHRlZFZhbHVlc1JlZixcbiAgZWFnZXJWYWx1ZXNSZWYsXG4gIGdyb3VwSWQsXG4gIGxheW91dCxcbiAgcGFuZWxEYXRhQXJyYXksXG4gIHBhbmVsR3JvdXBFbGVtZW50LFxuICBzZXRMYXlvdXRcbn0pIHtcbiAgdXNlUmVmKHtcbiAgICBkaWRXYXJuQWJvdXRNaXNzaW5nUmVzaXplSGFuZGxlOiBmYWxzZVxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXBhbmVsR3JvdXBFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVhZ2VyVmFsdWVzID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBhc3NlcnQoZWFnZXJWYWx1ZXMsIGBFYWdlciB2YWx1ZXMgbm90IGZvdW5kYCk7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXM7XG4gICAgY29uc3QgZ3JvdXBFbGVtZW50ID0gZ2V0UGFuZWxHcm91cEVsZW1lbnQoZ3JvdXBJZCwgcGFuZWxHcm91cEVsZW1lbnQpO1xuICAgIGFzc2VydChncm91cEVsZW1lbnQgIT0gbnVsbCwgYE5vIGdyb3VwIGZvdW5kIGZvciBpZCBcIiR7Z3JvdXBJZH1cImApO1xuICAgIGNvbnN0IGhhbmRsZXMgPSBnZXRSZXNpemVIYW5kbGVFbGVtZW50c0Zvckdyb3VwKGdyb3VwSWQsIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgICBhc3NlcnQoaGFuZGxlcywgYE5vIHJlc2l6ZSBoYW5kbGVzIGZvdW5kIGZvciBncm91cCBpZCBcIiR7Z3JvdXBJZH1cImApO1xuICAgIGNvbnN0IGNsZWFudXBGdW5jdGlvbnMgPSBoYW5kbGVzLm1hcChoYW5kbGUgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlSWQgPSBoYW5kbGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYW5lbC1yZXNpemUtaGFuZGxlLWlkXCIpO1xuICAgICAgYXNzZXJ0KGhhbmRsZUlkLCBgUmVzaXplIGhhbmRsZSBlbGVtZW50IGhhcyBubyBoYW5kbGUgaWQgYXR0cmlidXRlYCk7XG4gICAgICBjb25zdCBbaWRCZWZvcmUsIGlkQWZ0ZXJdID0gZ2V0UmVzaXplSGFuZGxlUGFuZWxJZHMoZ3JvdXBJZCwgaGFuZGxlSWQsIHBhbmVsRGF0YUFycmF5LCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gICAgICBpZiAoaWRCZWZvcmUgPT0gbnVsbCB8fCBpZEFmdGVyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgICAgfVxuICAgICAgY29uc3Qgb25LZXlEb3duID0gZXZlbnQgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICAgIGNhc2UgXCJFbnRlclwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhbmVsRGF0YUFycmF5LmZpbmRJbmRleChwYW5lbERhdGEgPT4gcGFuZWxEYXRhLmlkID09PSBpZEJlZm9yZSk7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFuZWxEYXRhID0gcGFuZWxEYXRhQXJyYXlbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGFzc2VydChwYW5lbERhdGEsIGBObyBwYW5lbCBkYXRhIGZvdW5kIGZvciBpbmRleCAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBsYXlvdXRbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgICAgICAgICAgICAgY29sbGFwc2libGUsXG4gICAgICAgICAgICAgICAgICBtaW5TaXplID0gMFxuICAgICAgICAgICAgICAgIH0gPSBwYW5lbERhdGEuY29uc3RyYWludHM7XG4gICAgICAgICAgICAgICAgaWYgKHNpemUgIT0gbnVsbCAmJiBjb2xsYXBzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dExheW91dCA9IGFkanVzdExheW91dEJ5RGVsdGEoe1xuICAgICAgICAgICAgICAgICAgICBkZWx0YTogZnV6enlOdW1iZXJzRXF1YWwoc2l6ZSwgY29sbGFwc2VkU2l6ZSkgPyBtaW5TaXplIC0gY29sbGFwc2VkU2l6ZSA6IGNvbGxhcHNlZFNpemUgLSBzaXplLFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsTGF5b3V0OiBsYXlvdXQsXG4gICAgICAgICAgICAgICAgICAgIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsRGF0YUFycmF5Lm1hcChwYW5lbERhdGEgPT4gcGFuZWxEYXRhLmNvbnN0cmFpbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgcGl2b3RJbmRpY2VzOiBkZXRlcm1pbmVQaXZvdEluZGljZXMoZ3JvdXBJZCwgaGFuZGxlSWQsIHBhbmVsR3JvdXBFbGVtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgcHJldkxheW91dDogbGF5b3V0LFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyOiBcImtleWJvYXJkXCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKGxheW91dCAhPT0gbmV4dExheW91dCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRMYXlvdXQobmV4dExheW91dCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBoYW5kbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFudXBGdW5jdGlvbnMuZm9yRWFjaChjbGVhbnVwRnVuY3Rpb24gPT4gY2xlYW51cEZ1bmN0aW9uKCkpO1xuICAgIH07XG4gIH0sIFtwYW5lbEdyb3VwRWxlbWVudCwgY29tbWl0dGVkVmFsdWVzUmVmLCBlYWdlclZhbHVlc1JlZiwgZ3JvdXBJZCwgbGF5b3V0LCBwYW5lbERhdGFBcnJheSwgc2V0TGF5b3V0XSk7XG59XG5cbmZ1bmN0aW9uIGFyZUVxdWFsKGFycmF5QSwgYXJyYXlCKSB7XG4gIGlmIChhcnJheUEubGVuZ3RoICE9PSBhcnJheUIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcnJheUEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKGFycmF5QVtpbmRleF0gIT09IGFycmF5QltpbmRleF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldFJlc2l6ZUV2ZW50Q3Vyc29yUG9zaXRpb24oZGlyZWN0aW9uLCBldmVudCkge1xuICBjb25zdCBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSBnZXRSZXNpemVFdmVudENvb3JkaW5hdGVzKGV2ZW50KTtcbiAgcmV0dXJuIGlzSG9yaXpvbnRhbCA/IHggOiB5O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVEcmFnT2Zmc2V0UGVyY2VudGFnZShldmVudCwgZHJhZ0hhbmRsZUlkLCBkaXJlY3Rpb24sIGluaXRpYWxEcmFnU3RhdGUsIHBhbmVsR3JvdXBFbGVtZW50KSB7XG4gIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIGNvbnN0IGhhbmRsZUVsZW1lbnQgPSBnZXRSZXNpemVIYW5kbGVFbGVtZW50KGRyYWdIYW5kbGVJZCwgcGFuZWxHcm91cEVsZW1lbnQpO1xuICBhc3NlcnQoaGFuZGxlRWxlbWVudCwgYE5vIHJlc2l6ZSBoYW5kbGUgZWxlbWVudCBmb3VuZCBmb3IgaWQgXCIke2RyYWdIYW5kbGVJZH1cImApO1xuICBjb25zdCBncm91cElkID0gaGFuZGxlRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBhbmVsLWdyb3VwLWlkXCIpO1xuICBhc3NlcnQoZ3JvdXBJZCwgYFJlc2l6ZSBoYW5kbGUgZWxlbWVudCBoYXMgbm8gZ3JvdXAgaWQgYXR0cmlidXRlYCk7XG4gIGxldCB7XG4gICAgaW5pdGlhbEN1cnNvclBvc2l0aW9uXG4gIH0gPSBpbml0aWFsRHJhZ1N0YXRlO1xuICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IGdldFJlc2l6ZUV2ZW50Q3Vyc29yUG9zaXRpb24oZGlyZWN0aW9uLCBldmVudCk7XG4gIGNvbnN0IGdyb3VwRWxlbWVudCA9IGdldFBhbmVsR3JvdXBFbGVtZW50KGdyb3VwSWQsIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgYXNzZXJ0KGdyb3VwRWxlbWVudCwgYE5vIGdyb3VwIGVsZW1lbnQgZm91bmQgZm9yIGlkIFwiJHtncm91cElkfVwiYCk7XG4gIGNvbnN0IGdyb3VwUmVjdCA9IGdyb3VwRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZ3JvdXBTaXplSW5QaXhlbHMgPSBpc0hvcml6b250YWwgPyBncm91cFJlY3Qud2lkdGggOiBncm91cFJlY3QuaGVpZ2h0O1xuICBjb25zdCBvZmZzZXRQaXhlbHMgPSBjdXJzb3JQb3NpdGlvbiAtIGluaXRpYWxDdXJzb3JQb3NpdGlvbjtcbiAgY29uc3Qgb2Zmc2V0UGVyY2VudGFnZSA9IG9mZnNldFBpeGVscyAvIGdyb3VwU2l6ZUluUGl4ZWxzICogMTAwO1xuICByZXR1cm4gb2Zmc2V0UGVyY2VudGFnZTtcbn1cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvbW92ZW1lbnRYXG5mdW5jdGlvbiBjYWxjdWxhdGVEZWx0YVBlcmNlbnRhZ2UoZXZlbnQsIGRyYWdIYW5kbGVJZCwgZGlyZWN0aW9uLCBpbml0aWFsRHJhZ1N0YXRlLCBrZXlib2FyZFJlc2l6ZUJ5LCBwYW5lbEdyb3VwRWxlbWVudCkge1xuICBpZiAoaXNLZXlEb3duKGV2ZW50KSkge1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gICAgbGV0IGRlbHRhID0gMDtcbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIGRlbHRhID0gMTAwO1xuICAgIH0gZWxzZSBpZiAoa2V5Ym9hcmRSZXNpemVCeSAhPSBudWxsKSB7XG4gICAgICBkZWx0YSA9IGtleWJvYXJkUmVzaXplQnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbHRhID0gMTA7XG4gICAgfVxuICAgIGxldCBtb3ZlbWVudCA9IDA7XG4gICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgbW92ZW1lbnQgPSBpc0hvcml6b250YWwgPyAwIDogZGVsdGE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgICBtb3ZlbWVudCA9IGlzSG9yaXpvbnRhbCA/IC1kZWx0YSA6IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgbW92ZW1lbnQgPSBpc0hvcml6b250YWwgPyBkZWx0YSA6IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgbW92ZW1lbnQgPSBpc0hvcml6b250YWwgPyAwIDogLWRlbHRhO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJFbmRcIjpcbiAgICAgICAgbW92ZW1lbnQgPSAxMDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgbW92ZW1lbnQgPSAtMTAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG1vdmVtZW50O1xuICB9IGVsc2Uge1xuICAgIGlmIChpbml0aWFsRHJhZ1N0YXRlID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gY2FsY3VsYXRlRHJhZ09mZnNldFBlcmNlbnRhZ2UoZXZlbnQsIGRyYWdIYW5kbGVJZCwgZGlyZWN0aW9uLCBpbml0aWFsRHJhZ1N0YXRlLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gIH1cbn1cblxuLy8gTGF5b3V0IHNob3VsZCBiZSBwcmUtY29udmVydGVkIGludG8gcGVyY2VudGFnZXNcbmZ1bmN0aW9uIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbHNBcnJheSwgbGF5b3V0LCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwKSB7XG4gIGxheW91dC5mb3JFYWNoKChzaXplLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBhbmVsRGF0YSA9IHBhbmVsc0FycmF5W2luZGV4XTtcbiAgICBhc3NlcnQocGFuZWxEYXRhLCBgUGFuZWwgZGF0YSBub3QgZm91bmQgZm9yIGluZGV4ICR7aW5kZXh9YCk7XG4gICAgY29uc3Qge1xuICAgICAgY2FsbGJhY2tzLFxuICAgICAgY29uc3RyYWludHMsXG4gICAgICBpZDogcGFuZWxJZFxuICAgIH0gPSBwYW5lbERhdGE7XG4gICAgY29uc3Qge1xuICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICBjb2xsYXBzaWJsZVxuICAgIH0gPSBjb25zdHJhaW50cztcbiAgICBjb25zdCBsYXN0Tm90aWZpZWRTaXplID0gcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFtwYW5lbElkXTtcbiAgICBpZiAobGFzdE5vdGlmaWVkU2l6ZSA9PSBudWxsIHx8IHNpemUgIT09IGxhc3ROb3RpZmllZFNpemUpIHtcbiAgICAgIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBbcGFuZWxJZF0gPSBzaXplO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbkNvbGxhcHNlLFxuICAgICAgICBvbkV4cGFuZCxcbiAgICAgICAgb25SZXNpemVcbiAgICAgIH0gPSBjYWxsYmFja3M7XG4gICAgICBpZiAob25SZXNpemUpIHtcbiAgICAgICAgb25SZXNpemUoc2l6ZSwgbGFzdE5vdGlmaWVkU2l6ZSk7XG4gICAgICB9XG4gICAgICBpZiAoY29sbGFwc2libGUgJiYgKG9uQ29sbGFwc2UgfHwgb25FeHBhbmQpKSB7XG4gICAgICAgIGlmIChvbkV4cGFuZCAmJiAobGFzdE5vdGlmaWVkU2l6ZSA9PSBudWxsIHx8IGZ1enp5TnVtYmVyc0VxdWFsJDEobGFzdE5vdGlmaWVkU2l6ZSwgY29sbGFwc2VkU2l6ZSkpICYmICFmdXp6eU51bWJlcnNFcXVhbCQxKHNpemUsIGNvbGxhcHNlZFNpemUpKSB7XG4gICAgICAgICAgb25FeHBhbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Db2xsYXBzZSAmJiAobGFzdE5vdGlmaWVkU2l6ZSA9PSBudWxsIHx8ICFmdXp6eU51bWJlcnNFcXVhbCQxKGxhc3ROb3RpZmllZFNpemUsIGNvbGxhcHNlZFNpemUpKSAmJiBmdXp6eU51bWJlcnNFcXVhbCQxKHNpemUsIGNvbGxhcHNlZFNpemUpKSB7XG4gICAgICAgICAgb25Db2xsYXBzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUxheW91dHMoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGFbaW5kZXhdICE9IGJbaW5kZXhdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIFRoaXMgbWV0aG9kIHJldHVybnMgYSBudW1iZXIgYmV0d2VlbiAxIGFuZCAxMDAgcmVwcmVzZW50aW5nXG5cbi8vIHRoZSAlIG9mIHRoZSBncm91cCdzIG92ZXJhbGwgc3BhY2UgdGhpcyBwYW5lbCBzaG91bGQgb2NjdXB5LlxuZnVuY3Rpb24gY29tcHV0ZVBhbmVsRmxleEJveFN0eWxlKHtcbiAgZGVmYXVsdFNpemUsXG4gIGRyYWdTdGF0ZSxcbiAgbGF5b3V0LFxuICBwYW5lbERhdGEsXG4gIHBhbmVsSW5kZXgsXG4gIHByZWNpc2lvbiA9IDNcbn0pIHtcbiAgY29uc3Qgc2l6ZSA9IGxheW91dFtwYW5lbEluZGV4XTtcbiAgbGV0IGZsZXhHcm93O1xuICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgLy8gSW5pdGlhbCByZW5kZXIgKGJlZm9yZSBwYW5lbHMgaGF2ZSByZWdpc3RlcmVkIHRoZW1zZWx2ZXMpXG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCBzZXJ2ZXIgcmVuZGVyaW5nLCBmYWxsIGJhY2sgdG8gZGVmYXVsdCBzaXplIGlmIHByb3ZpZGVkXG4gICAgZmxleEdyb3cgPSBkZWZhdWx0U2l6ZSAhPSB1bmRlZmluZWQgPyBkZWZhdWx0U2l6ZS50b1ByZWNpc2lvbihwcmVjaXNpb24pIDogXCIxXCI7XG4gIH0gZWxzZSBpZiAocGFuZWxEYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogU2luZ2xlIHBhbmVsIGdyb3VwIHNob3VsZCBhbHdheXMgZmlsbCBmdWxsIHdpZHRoL2hlaWdodFxuICAgIGZsZXhHcm93ID0gXCIxXCI7XG4gIH0gZWxzZSB7XG4gICAgZmxleEdyb3cgPSBzaXplLnRvUHJlY2lzaW9uKHByZWNpc2lvbik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmbGV4QmFzaXM6IDAsXG4gICAgZmxleEdyb3csXG4gICAgZmxleFNocmluazogMSxcbiAgICAvLyBXaXRob3V0IHRoaXMsIFBhbmVsIHNpemVzIG1heSBiZSB1bmludGVudGlvbmFsbHkgb3ZlcnJpZGRlbiBieSB0aGVpciBjb250ZW50XG4gICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgLy8gRGlzYWJsZSBwb2ludGVyIGV2ZW50cyBpbnNpZGUgb2YgYSBwYW5lbCBkdXJpbmcgcmVzaXplXG4gICAgLy8gVGhpcyBhdm9pZCBlZGdlIGNhc2VzIGxpa2UgbmVzdGVkIGlmcmFtZXNcbiAgICBwb2ludGVyRXZlbnRzOiBkcmFnU3RhdGUgIT09IG51bGwgPyBcIm5vbmVcIiA6IHVuZGVmaW5lZFxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWJvdW5jZShjYWxsYmFjaywgZHVyYXRpb25NcyA9IDEwKSB7XG4gIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICBsZXQgY2FsbGFibGUgPSAoLi4uYXJncykgPT4ge1xuICAgIGlmICh0aW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgIH0sIGR1cmF0aW9uTXMpO1xuICB9O1xuICByZXR1cm4gY2FsbGFibGU7XG59XG5cbi8vIFBhbmVsR3JvdXAgbWlnaHQgYmUgcmVuZGVyaW5nIGluIGEgc2VydmVyLXNpZGUgZW52aXJvbm1lbnQgd2hlcmUgbG9jYWxTdG9yYWdlIGlzIG5vdCBhdmFpbGFibGVcbi8vIG9yIG9uIGEgYnJvd3NlciB3aXRoIGNvb2tpZXMvc3RvcmFnZSBkaXNhYmxlZC5cbi8vIEluIGVpdGhlciBjYXNlLCB0aGlzIGZ1bmN0aW9uIGF2b2lkcyBhY2Nlc3NpbmcgbG9jYWxTdG9yYWdlIHVudGlsIG5lZWRlZCxcbi8vIGFuZCBhdm9pZHMgdGhyb3dpbmcgdXNlci12aXNpYmxlIGVycm9ycy5cbmZ1bmN0aW9uIGluaXRpYWxpemVEZWZhdWx0U3RvcmFnZShzdG9yYWdlT2JqZWN0KSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIC8vIEJ5cGFzcyB0aGlzIGNoZWNrIGZvciBmdXR1cmUgY2FsbHNcbiAgICAgIHN0b3JhZ2VPYmplY3QuZ2V0SXRlbSA9IG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gICAgICB9O1xuICAgICAgc3RvcmFnZU9iamVjdC5zZXRJdGVtID0gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKG5hbWUsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImxvY2FsU3RvcmFnZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnRcIik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHN0b3JhZ2VPYmplY3QuZ2V0SXRlbSA9ICgpID0+IG51bGw7XG4gICAgc3RvcmFnZU9iamVjdC5zZXRJdGVtID0gKCkgPT4ge307XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UGFuZWxHcm91cEtleShhdXRvU2F2ZUlkKSB7XG4gIHJldHVybiBgcmVhY3QtcmVzaXphYmxlLXBhbmVsczoke2F1dG9TYXZlSWR9YDtcbn1cblxuLy8gTm90ZSB0aGF0IFBhbmVsIGlkcyBtaWdodCBiZSB1c2VyLXByb3ZpZGVkIChzdGFibGUpIG9yIHVzZUlkIGdlbmVyYXRlZCAobm9uLWRldGVybWluaXN0aWMpXG4vLyBzbyB0aGV5IHNob3VsZCBub3QgYmUgdXNlZCBhcyBwYXJ0IG9mIHRoZSBzZXJpYWxpemF0aW9uIGtleS5cbi8vIFVzaW5nIHRoZSBtaW4vbWF4IHNpemUgYXR0cmlidXRlcyBzaG91bGQgd29yayB3ZWxsIGVub3VnaCBhcyBhIGJhY2t1cC5cbi8vIFByZS1zb3J0aW5nIGJ5IG1pblNpemUgYWxsb3dzIHJlbWVtYmVyaW5nIGxheW91dHMgZXZlbiBpZiBwYW5lbHMgYXJlIHJlLW9yZGVyZWQvZHJhZ2dlZC5cbmZ1bmN0aW9uIGdldFBhbmVsS2V5KHBhbmVscykge1xuICByZXR1cm4gcGFuZWxzLm1hcChwYW5lbCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY29uc3RyYWludHMsXG4gICAgICBpZCxcbiAgICAgIGlkSXNGcm9tUHJvcHMsXG4gICAgICBvcmRlclxuICAgIH0gPSBwYW5lbDtcbiAgICBpZiAoaWRJc0Zyb21Qcm9wcykge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3JkZXIgPyBgJHtvcmRlcn06JHtKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cyl9YCA6IEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKTtcbiAgICB9XG4gIH0pLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSkuam9pbihcIixcIik7XG59XG5mdW5jdGlvbiBsb2FkU2VyaWFsaXplZFBhbmVsR3JvdXBTdGF0ZShhdXRvU2F2ZUlkLCBzdG9yYWdlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFuZWxHcm91cEtleSA9IGdldFBhbmVsR3JvdXBLZXkoYXV0b1NhdmVJZCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHN0b3JhZ2UuZ2V0SXRlbShwYW5lbEdyb3VwS2V5KTtcbiAgICBpZiAoc2VyaWFsaXplZCkge1xuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShzZXJpYWxpemVkKTtcbiAgICAgIGlmICh0eXBlb2YgcGFyc2VkID09PSBcIm9iamVjdFwiICYmIHBhcnNlZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge31cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzYXZlUGFuZWxHcm91cFN0YXRlKGF1dG9TYXZlSWQsIHBhbmVscywgcGFuZWxTaXplc0JlZm9yZUNvbGxhcHNlLCBzaXplcywgc3RvcmFnZSkge1xuICB2YXIgX2xvYWRTZXJpYWxpemVkUGFuZWxHMjtcbiAgY29uc3QgcGFuZWxHcm91cEtleSA9IGdldFBhbmVsR3JvdXBLZXkoYXV0b1NhdmVJZCk7XG4gIGNvbnN0IHBhbmVsS2V5ID0gZ2V0UGFuZWxLZXkocGFuZWxzKTtcbiAgY29uc3Qgc3RhdGUgPSAoX2xvYWRTZXJpYWxpemVkUGFuZWxHMiA9IGxvYWRTZXJpYWxpemVkUGFuZWxHcm91cFN0YXRlKGF1dG9TYXZlSWQsIHN0b3JhZ2UpKSAhPT0gbnVsbCAmJiBfbG9hZFNlcmlhbGl6ZWRQYW5lbEcyICE9PSB2b2lkIDAgPyBfbG9hZFNlcmlhbGl6ZWRQYW5lbEcyIDoge307XG4gIHN0YXRlW3BhbmVsS2V5XSA9IHtcbiAgICBleHBhbmRUb1NpemVzOiBPYmplY3QuZnJvbUVudHJpZXMocGFuZWxTaXplc0JlZm9yZUNvbGxhcHNlLmVudHJpZXMoKSksXG4gICAgbGF5b3V0OiBzaXplc1xuICB9O1xuICB0cnkge1xuICAgIHN0b3JhZ2Uuc2V0SXRlbShwYW5lbEdyb3VwS2V5LCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUGFuZWxDb25zdHJhaW50cyh7XG4gIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgcGFuZWxJZCxcbiAgcGFuZWxJbmRleFxufSkge1xuICB7XG4gICAgY29uc3Qgd2FybmluZ3MgPSBbXTtcbiAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzID0gcGFuZWxDb25zdHJhaW50c0FycmF5W3BhbmVsSW5kZXhdO1xuICAgIGFzc2VydChwYW5lbENvbnN0cmFpbnRzLCBgTm8gcGFuZWwgY29uc3RyYWludHMgZm91bmQgZm9yIGluZGV4ICR7cGFuZWxJbmRleH1gKTtcbiAgICBjb25zdCB7XG4gICAgICBjb2xsYXBzZWRTaXplID0gMCxcbiAgICAgIGNvbGxhcHNpYmxlID0gZmFsc2UsXG4gICAgICBkZWZhdWx0U2l6ZSxcbiAgICAgIG1heFNpemUgPSAxMDAsXG4gICAgICBtaW5TaXplID0gMFxuICAgIH0gPSBwYW5lbENvbnN0cmFpbnRzO1xuICAgIGlmIChtaW5TaXplID4gbWF4U2l6ZSkge1xuICAgICAgd2FybmluZ3MucHVzaChgbWluIHNpemUgKCR7bWluU2l6ZX0lKSBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiBtYXggc2l6ZSAoJHttYXhTaXplfSUpYCk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0U2l6ZSAhPSBudWxsKSB7XG4gICAgICBpZiAoZGVmYXVsdFNpemUgPCAwKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goXCJkZWZhdWx0IHNpemUgc2hvdWxkIG5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdFNpemUgPCBtaW5TaXplICYmICghY29sbGFwc2libGUgfHwgZGVmYXVsdFNpemUgIT09IGNvbGxhcHNlZFNpemUpKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goXCJkZWZhdWx0IHNpemUgc2hvdWxkIG5vdCBiZSBsZXNzIHRoYW4gbWluIHNpemVcIik7XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFNpemUgPiAxMDApIHtcbiAgICAgICAgd2FybmluZ3MucHVzaChcImRlZmF1bHQgc2l6ZSBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMDBcIik7XG4gICAgICB9IGVsc2UgaWYgKGRlZmF1bHRTaXplID4gbWF4U2l6ZSkge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKFwiZGVmYXVsdCBzaXplIHNob3VsZCBub3QgYmUgZ3JlYXRlciB0aGFuIG1heCBzaXplXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sbGFwc2VkU2l6ZSA+IG1pblNpemUpIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goXCJjb2xsYXBzZWQgc2l6ZSBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiBtaW4gc2l6ZVwiKTtcbiAgICB9XG4gICAgaWYgKHdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBwYW5lbElkICE9IG51bGwgPyBgUGFuZWwgXCIke3BhbmVsSWR9XCJgIDogXCJQYW5lbFwiO1xuICAgICAgY29uc29sZS53YXJuKGAke25hbWV9IGhhcyBhbiBpbnZhbGlkIGNvbmZpZ3VyYXRpb246XFxuXFxuJHt3YXJuaW5ncy5qb2luKFwiXFxuXCIpfWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gQWxsIHVuaXRzIG11c3QgYmUgaW4gcGVyY2VudGFnZXM7IHBpeGVsIHZhbHVlcyBzaG91bGQgYmUgcHJlLWNvbnZlcnRlZFxuZnVuY3Rpb24gdmFsaWRhdGVQYW5lbEdyb3VwTGF5b3V0KHtcbiAgbGF5b3V0OiBwcmV2TGF5b3V0LFxuICBwYW5lbENvbnN0cmFpbnRzXG59KSB7XG4gIGNvbnN0IG5leHRMYXlvdXQgPSBbLi4ucHJldkxheW91dF07XG4gIGNvbnN0IG5leHRMYXlvdXRUb3RhbFNpemUgPSBuZXh0TGF5b3V0LnJlZHVjZSgoYWNjdW11bGF0ZWQsIGN1cnJlbnQpID0+IGFjY3VtdWxhdGVkICsgY3VycmVudCwgMCk7XG5cbiAgLy8gVmFsaWRhdGUgbGF5b3V0IGV4cGVjdGF0aW9uc1xuICBpZiAobmV4dExheW91dC5sZW5ndGggIT09IHBhbmVsQ29uc3RyYWludHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgRXJyb3IoYEludmFsaWQgJHtwYW5lbENvbnN0cmFpbnRzLmxlbmd0aH0gcGFuZWwgbGF5b3V0OiAke25leHRMYXlvdXQubWFwKHNpemUgPT4gYCR7c2l6ZX0lYCkuam9pbihcIiwgXCIpfWApO1xuICB9IGVsc2UgaWYgKCFmdXp6eU51bWJlcnNFcXVhbChuZXh0TGF5b3V0VG90YWxTaXplLCAxMDApKSB7XG4gICAgLy8gVGhpcyBpcyBub3QgaWRlYWwgc28gd2Ugc2hvdWxkIHdhcm4gYWJvdXQgaXQsIGJ1dCBpdCBtYXkgYmUgcmVjb3ZlcmFibGUgaW4gc29tZSBjYXNlc1xuICAgIC8vIChlc3BlY2lhbGx5IGlmIHRoZSBhbW91bnQgaXMgc21hbGwpXG4gICAge1xuICAgICAgY29uc29sZS53YXJuKGBXQVJOSU5HOiBJbnZhbGlkIGxheW91dCB0b3RhbCBzaXplOiAke25leHRMYXlvdXQubWFwKHNpemUgPT4gYCR7c2l6ZX0lYCkuam9pbihcIiwgXCIpfS4gTGF5b3V0IG5vcm1hbGl6YXRpb24gd2lsbCBiZSBhcHBsaWVkLmApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGFuZWxDb25zdHJhaW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHVuc2FmZVNpemUgPSBuZXh0TGF5b3V0W2luZGV4XTtcbiAgICAgIGFzc2VydCh1bnNhZmVTaXplICE9IG51bGwsIGBObyBsYXlvdXQgZGF0YSBmb3VuZCBmb3IgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgIGNvbnN0IHNhZmVTaXplID0gMTAwIC8gbmV4dExheW91dFRvdGFsU2l6ZSAqIHVuc2FmZVNpemU7XG4gICAgICBuZXh0TGF5b3V0W2luZGV4XSA9IHNhZmVTaXplO1xuICAgIH1cbiAgfVxuICBsZXQgcmVtYWluaW5nU2l6ZSA9IDA7XG5cbiAgLy8gRmlyc3QgcGFzczogVmFsaWRhdGUgdGhlIHByb3Bvc2VkIGxheW91dCBnaXZlbiBlYWNoIHBhbmVsJ3MgY29uc3RyYWludHNcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhbmVsQ29uc3RyYWludHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgdW5zYWZlU2l6ZSA9IG5leHRMYXlvdXRbaW5kZXhdO1xuICAgIGFzc2VydCh1bnNhZmVTaXplICE9IG51bGwsIGBObyBsYXlvdXQgZGF0YSBmb3VuZCBmb3IgaW5kZXggJHtpbmRleH1gKTtcbiAgICBjb25zdCBzYWZlU2l6ZSA9IHJlc2l6ZVBhbmVsKHtcbiAgICAgIHBhbmVsQ29uc3RyYWludHMsXG4gICAgICBwYW5lbEluZGV4OiBpbmRleCxcbiAgICAgIHNpemU6IHVuc2FmZVNpemVcbiAgICB9KTtcbiAgICBpZiAodW5zYWZlU2l6ZSAhPSBzYWZlU2l6ZSkge1xuICAgICAgcmVtYWluaW5nU2l6ZSArPSB1bnNhZmVTaXplIC0gc2FmZVNpemU7XG4gICAgICBuZXh0TGF5b3V0W2luZGV4XSA9IHNhZmVTaXplO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZXJlIGlzIGFkZGl0aW9uYWwsIGxlZnQgb3ZlciBzcGFjZSwgYXNzaWduIGl0IHRvIGFueSBwYW5lbChzKSB0aGF0IHBlcm1pdHMgaXRcbiAgLy8gKEl0J3Mgbm90IHdvcnRoIHRha2luZyBtdWx0aXBsZSBhZGRpdGlvbmFsIHBhc3NlcyB0byBldmVubHkgZGlzdHJpYnV0ZSlcbiAgaWYgKCFmdXp6eU51bWJlcnNFcXVhbChyZW1haW5pbmdTaXplLCAwKSkge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYW5lbENvbnN0cmFpbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgcHJldlNpemUgPSBuZXh0TGF5b3V0W2luZGV4XTtcbiAgICAgIGFzc2VydChwcmV2U2l6ZSAhPSBudWxsLCBgTm8gbGF5b3V0IGRhdGEgZm91bmQgZm9yIGluZGV4ICR7aW5kZXh9YCk7XG4gICAgICBjb25zdCB1bnNhZmVTaXplID0gcHJldlNpemUgKyByZW1haW5pbmdTaXplO1xuICAgICAgY29uc3Qgc2FmZVNpemUgPSByZXNpemVQYW5lbCh7XG4gICAgICAgIHBhbmVsQ29uc3RyYWludHMsXG4gICAgICAgIHBhbmVsSW5kZXg6IGluZGV4LFxuICAgICAgICBzaXplOiB1bnNhZmVTaXplXG4gICAgICB9KTtcbiAgICAgIGlmIChwcmV2U2l6ZSAhPT0gc2FmZVNpemUpIHtcbiAgICAgICAgcmVtYWluaW5nU2l6ZSAtPSBzYWZlU2l6ZSAtIHByZXZTaXplO1xuICAgICAgICBuZXh0TGF5b3V0W2luZGV4XSA9IHNhZmVTaXplO1xuXG4gICAgICAgIC8vIE9uY2Ugd2UndmUgdXNlZCB1cCB0aGUgcmVtYWluZGVyLCBiYWlsXG4gICAgICAgIGlmIChmdXp6eU51bWJlcnNFcXVhbChyZW1haW5pbmdTaXplLCAwKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0TGF5b3V0O1xufVxuXG5jb25zdCBMT0NBTF9TVE9SQUdFX0RFQk9VTkNFX0lOVEVSVkFMID0gMTAwO1xuY29uc3QgZGVmYXVsdFN0b3JhZ2UgPSB7XG4gIGdldEl0ZW06IG5hbWUgPT4ge1xuICAgIGluaXRpYWxpemVEZWZhdWx0U3RvcmFnZShkZWZhdWx0U3RvcmFnZSk7XG4gICAgcmV0dXJuIGRlZmF1bHRTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gIH0sXG4gIHNldEl0ZW06IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgIGluaXRpYWxpemVEZWZhdWx0U3RvcmFnZShkZWZhdWx0U3RvcmFnZSk7XG4gICAgZGVmYXVsdFN0b3JhZ2Uuc2V0SXRlbShuYW1lLCB2YWx1ZSk7XG4gIH1cbn07XG5jb25zdCBkZWJvdW5jZU1hcCA9IHt9O1xuZnVuY3Rpb24gUGFuZWxHcm91cFdpdGhGb3J3YXJkZWRSZWYoe1xuICBhdXRvU2F2ZUlkID0gbnVsbCxcbiAgY2hpbGRyZW4sXG4gIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzID0gXCJcIixcbiAgZGlyZWN0aW9uLFxuICBmb3J3YXJkZWRSZWYsXG4gIGlkOiBpZEZyb21Qcm9wcyA9IG51bGwsXG4gIG9uTGF5b3V0ID0gbnVsbCxcbiAga2V5Ym9hcmRSZXNpemVCeSA9IG51bGwsXG4gIHN0b3JhZ2UgPSBkZWZhdWx0U3RvcmFnZSxcbiAgc3R5bGU6IHN0eWxlRnJvbVByb3BzLFxuICB0YWdOYW1lOiBUeXBlID0gXCJkaXZcIixcbiAgLi4ucmVzdFxufSkge1xuICBjb25zdCBncm91cElkID0gdXNlVW5pcXVlSWQoaWRGcm9tUHJvcHMpO1xuICBjb25zdCBwYW5lbEdyb3VwRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW2RyYWdTdGF0ZSwgc2V0RHJhZ1N0YXRlXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbbGF5b3V0LCBzZXRMYXlvdXRdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmID0gdXNlUmVmKHt9KTtcbiAgY29uc3QgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2VSZWYgPSB1c2VSZWYobmV3IE1hcCgpKTtcbiAgY29uc3QgcHJldkRlbHRhUmVmID0gdXNlUmVmKDApO1xuICBjb25zdCBjb21taXR0ZWRWYWx1ZXNSZWYgPSB1c2VSZWYoe1xuICAgIGF1dG9TYXZlSWQsXG4gICAgZGlyZWN0aW9uLFxuICAgIGRyYWdTdGF0ZSxcbiAgICBpZDogZ3JvdXBJZCxcbiAgICBrZXlib2FyZFJlc2l6ZUJ5LFxuICAgIG9uTGF5b3V0LFxuICAgIHN0b3JhZ2VcbiAgfSk7XG4gIGNvbnN0IGVhZ2VyVmFsdWVzUmVmID0gdXNlUmVmKHtcbiAgICBsYXlvdXQsXG4gICAgcGFuZWxEYXRhQXJyYXk6IFtdLFxuICAgIHBhbmVsRGF0YUFycmF5Q2hhbmdlZDogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGRldldhcm5pbmdzUmVmID0gdXNlUmVmKHtcbiAgICBkaWRMb2dJZEFuZE9yZGVyV2FybmluZzogZmFsc2UsXG4gICAgZGlkTG9nUGFuZWxDb25zdHJhaW50c1dhcm5pbmc6IGZhbHNlLFxuICAgIHByZXZQYW5lbElkczogW11cbiAgfSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKSA9PiAoe1xuICAgIGdldElkOiAoKSA9PiBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudC5pZCxcbiAgICBnZXRMYXlvdXQ6ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5b3V0XG4gICAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfSxcbiAgICBzZXRMYXlvdXQ6IHVuc2FmZUxheW91dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uTGF5b3V0XG4gICAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxheW91dDogcHJldkxheW91dCxcbiAgICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgY29uc3Qgc2FmZUxheW91dCA9IHZhbGlkYXRlUGFuZWxHcm91cExheW91dCh7XG4gICAgICAgIGxheW91dDogdW5zYWZlTGF5b3V0LFxuICAgICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbERhdGFBcnJheS5tYXAocGFuZWxEYXRhID0+IHBhbmVsRGF0YS5jb25zdHJhaW50cylcbiAgICAgIH0pO1xuICAgICAgaWYgKCFhcmVFcXVhbChwcmV2TGF5b3V0LCBzYWZlTGF5b3V0KSkge1xuICAgICAgICBzZXRMYXlvdXQoc2FmZUxheW91dCk7XG4gICAgICAgIGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQubGF5b3V0ID0gc2FmZUxheW91dDtcbiAgICAgICAgaWYgKG9uTGF5b3V0KSB7XG4gICAgICAgICAgb25MYXlvdXQoc2FmZUxheW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbFBhbmVsQ2FsbGJhY2tzKHBhbmVsRGF0YUFycmF5LCBzYWZlTGF5b3V0LCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSksIFtdKTtcbiAgdXNlV2luZG93U3BsaXR0ZXJQYW5lbEdyb3VwQmVoYXZpb3Ioe1xuICAgIGNvbW1pdHRlZFZhbHVlc1JlZixcbiAgICBlYWdlclZhbHVlc1JlZixcbiAgICBncm91cElkLFxuICAgIGxheW91dCxcbiAgICBwYW5lbERhdGFBcnJheTogZWFnZXJWYWx1ZXNSZWYuY3VycmVudC5wYW5lbERhdGFBcnJheSxcbiAgICBzZXRMYXlvdXQsXG4gICAgcGFuZWxHcm91cEVsZW1lbnQ6IHBhbmVsR3JvdXBFbGVtZW50UmVmLmN1cnJlbnRcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcblxuICAgIC8vIElmIHRoaXMgcGFuZWwgaGFzIGJlZW4gY29uZmlndXJlZCB0byBwZXJzaXN0IHNpemluZyBpbmZvcm1hdGlvbiwgc2F2ZSBzaXplcyB0byBsb2NhbCBzdG9yYWdlLlxuICAgIGlmIChhdXRvU2F2ZUlkKSB7XG4gICAgICBpZiAobGF5b3V0Lmxlbmd0aCA9PT0gMCB8fCBsYXlvdXQubGVuZ3RoICE9PSBwYW5lbERhdGFBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGRlYm91bmNlZFNhdmUgPSBkZWJvdW5jZU1hcFthdXRvU2F2ZUlkXTtcblxuICAgICAgLy8gTGltaXQgdGhlIGZyZXF1ZW5jeSBvZiBsb2NhbFN0b3JhZ2UgdXBkYXRlcy5cbiAgICAgIGlmIChkZWJvdW5jZWRTYXZlID09IG51bGwpIHtcbiAgICAgICAgZGVib3VuY2VkU2F2ZSA9IGRlYm91bmNlKHNhdmVQYW5lbEdyb3VwU3RhdGUsIExPQ0FMX1NUT1JBR0VfREVCT1VOQ0VfSU5URVJWQUwpO1xuICAgICAgICBkZWJvdW5jZU1hcFthdXRvU2F2ZUlkXSA9IGRlYm91bmNlZFNhdmU7XG4gICAgICB9XG5cbiAgICAgIC8vIENsb25lIG11dGFibGUgZGF0YSBiZWZvcmUgcGFzc2luZyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLFxuICAgICAgLy8gZWxzZSB3ZSBydW4gdGhlIHJpc2sgb2Ygc2F2aW5nIGFuIGluY29ycmVjdCBjb21iaW5hdGlvbiBvZiBtdXRhYmxlIGFuZCBpbW11dGFibGUgdmFsdWVzIHRvIHN0YXRlLlxuICAgICAgY29uc3QgY2xvbmVkUGFuZWxEYXRhQXJyYXkgPSBbLi4ucGFuZWxEYXRhQXJyYXldO1xuICAgICAgY29uc3QgY2xvbmVkUGFuZWxTaXplc0JlZm9yZUNvbGxhcHNlID0gbmV3IE1hcChwYW5lbFNpemVCZWZvcmVDb2xsYXBzZVJlZi5jdXJyZW50KTtcbiAgICAgIGRlYm91bmNlZFNhdmUoYXV0b1NhdmVJZCwgY2xvbmVkUGFuZWxEYXRhQXJyYXksIGNsb25lZFBhbmVsU2l6ZXNCZWZvcmVDb2xsYXBzZSwgbGF5b3V0LCBzdG9yYWdlKTtcbiAgICB9XG4gIH0sIFthdXRvU2F2ZUlkLCBsYXlvdXQsIHN0b3JhZ2VdKTtcblxuICAvLyBERVYgd2FybmluZ3NcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGlkTG9nSWRBbmRPcmRlcldhcm5pbmcsXG4gICAgICAgIGRpZExvZ1BhbmVsQ29uc3RyYWludHNXYXJuaW5nLFxuICAgICAgICBwcmV2UGFuZWxJZHNcbiAgICAgIH0gPSBkZXZXYXJuaW5nc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKCFkaWRMb2dJZEFuZE9yZGVyV2FybmluZykge1xuICAgICAgICBjb25zdCBwYW5lbElkcyA9IHBhbmVsRGF0YUFycmF5Lm1hcCgoe1xuICAgICAgICAgIGlkXG4gICAgICAgIH0pID0+IGlkKTtcbiAgICAgICAgZGV2V2FybmluZ3NSZWYuY3VycmVudC5wcmV2UGFuZWxJZHMgPSBwYW5lbElkcztcbiAgICAgICAgY29uc3QgcGFuZWxzSGF2ZUNoYW5nZWQgPSBwcmV2UGFuZWxJZHMubGVuZ3RoID4gMCAmJiAhYXJlRXF1YWwocHJldlBhbmVsSWRzLCBwYW5lbElkcyk7XG4gICAgICAgIGlmIChwYW5lbHNIYXZlQ2hhbmdlZCkge1xuICAgICAgICAgIGlmIChwYW5lbERhdGFBcnJheS5maW5kKCh7XG4gICAgICAgICAgICBpZElzRnJvbVByb3BzLFxuICAgICAgICAgICAgb3JkZXJcbiAgICAgICAgICB9KSA9PiAhaWRJc0Zyb21Qcm9wcyB8fCBvcmRlciA9PSBudWxsKSkge1xuICAgICAgICAgICAgZGV2V2FybmluZ3NSZWYuY3VycmVudC5kaWRMb2dJZEFuZE9yZGVyV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFdBUk5JTkc6IFBhbmVsIGlkIGFuZCBvcmRlciBwcm9wcyByZWNvbW1lbmRlZCB3aGVuIHBhbmVscyBhcmUgZHluYW1pY2FsbHkgcmVuZGVyZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZGlkTG9nUGFuZWxDb25zdHJhaW50c1dhcm5pbmcpIHtcbiAgICAgICAgY29uc3QgcGFuZWxDb25zdHJhaW50cyA9IHBhbmVsRGF0YUFycmF5Lm1hcChwYW5lbERhdGEgPT4gcGFuZWxEYXRhLmNvbnN0cmFpbnRzKTtcbiAgICAgICAgZm9yIChsZXQgcGFuZWxJbmRleCA9IDA7IHBhbmVsSW5kZXggPCBwYW5lbENvbnN0cmFpbnRzLmxlbmd0aDsgcGFuZWxJbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgcGFuZWxEYXRhID0gcGFuZWxEYXRhQXJyYXlbcGFuZWxJbmRleF07XG4gICAgICAgICAgYXNzZXJ0KHBhbmVsRGF0YSwgYFBhbmVsIGRhdGEgbm90IGZvdW5kIGZvciBpbmRleCAke3BhbmVsSW5kZXh9YCk7XG4gICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRlUGFuZWxDb25zdHJhaW50cyh7XG4gICAgICAgICAgICBwYW5lbENvbnN0cmFpbnRzLFxuICAgICAgICAgICAgcGFuZWxJZDogcGFuZWxEYXRhLmlkLFxuICAgICAgICAgICAgcGFuZWxJbmRleFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgZGV2V2FybmluZ3NSZWYuY3VycmVudC5kaWRMb2dQYW5lbENvbnN0cmFpbnRzV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIEV4dGVybmFsIEFQSXMgYXJlIHNhZmUgdG8gbWVtb2l6ZSB2aWEgY29tbWl0dGVkIHZhbHVlcyByZWZcbiAgY29uc3QgY29sbGFwc2VQYW5lbCA9IHVzZUNhbGxiYWNrKHBhbmVsRGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb25MYXlvdXRcbiAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgbGF5b3V0OiBwcmV2TGF5b3V0LFxuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBpZiAocGFuZWxEYXRhLmNvbnN0cmFpbnRzLmNvbGxhcHNpYmxlKSB7XG4gICAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzQXJyYXkgPSBwYW5lbERhdGFBcnJheS5tYXAocGFuZWxEYXRhID0+IHBhbmVsRGF0YS5jb25zdHJhaW50cyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgICBwYW5lbFNpemUsXG4gICAgICAgIHBpdm90SW5kaWNlc1xuICAgICAgfSA9IHBhbmVsRGF0YUhlbHBlcihwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhLCBwcmV2TGF5b3V0KTtcbiAgICAgIGFzc2VydChwYW5lbFNpemUgIT0gbnVsbCwgYFBhbmVsIHNpemUgbm90IGZvdW5kIGZvciBwYW5lbCBcIiR7cGFuZWxEYXRhLmlkfVwiYCk7XG4gICAgICBpZiAoIWZ1enp5TnVtYmVyc0VxdWFsJDEocGFuZWxTaXplLCBjb2xsYXBzZWRTaXplKSkge1xuICAgICAgICAvLyBTdG9yZSBzaXplIGJlZm9yZSBjb2xsYXBzZTtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgc2l6ZSB0aGF0IGdldHMgcmVzdG9yZWQgaWYgdGhlIGV4cGFuZCgpIEFQSSBpcyB1c2VkLlxuICAgICAgICBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZVJlZi5jdXJyZW50LnNldChwYW5lbERhdGEuaWQsIHBhbmVsU2l6ZSk7XG4gICAgICAgIGNvbnN0IGlzTGFzdFBhbmVsID0gZmluZFBhbmVsRGF0YUluZGV4KHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEpID09PSBwYW5lbERhdGFBcnJheS5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBkZWx0YSA9IGlzTGFzdFBhbmVsID8gcGFuZWxTaXplIC0gY29sbGFwc2VkU2l6ZSA6IGNvbGxhcHNlZFNpemUgLSBwYW5lbFNpemU7XG4gICAgICAgIGNvbnN0IG5leHRMYXlvdXQgPSBhZGp1c3RMYXlvdXRCeURlbHRhKHtcbiAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICBpbml0aWFsTGF5b3V0OiBwcmV2TGF5b3V0LFxuICAgICAgICAgIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgICAgICAgICBwaXZvdEluZGljZXMsXG4gICAgICAgICAgcHJldkxheW91dCxcbiAgICAgICAgICB0cmlnZ2VyOiBcImltcGVyYXRpdmUtYXBpXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY29tcGFyZUxheW91dHMocHJldkxheW91dCwgbmV4dExheW91dCkpIHtcbiAgICAgICAgICBzZXRMYXlvdXQobmV4dExheW91dCk7XG4gICAgICAgICAgZWFnZXJWYWx1ZXNSZWYuY3VycmVudC5sYXlvdXQgPSBuZXh0TGF5b3V0O1xuICAgICAgICAgIGlmIChvbkxheW91dCkge1xuICAgICAgICAgICAgb25MYXlvdXQobmV4dExheW91dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbERhdGFBcnJheSwgbmV4dExheW91dCwgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIEV4dGVybmFsIEFQSXMgYXJlIHNhZmUgdG8gbWVtb2l6ZSB2aWEgY29tbWl0dGVkIHZhbHVlcyByZWZcbiAgY29uc3QgZXhwYW5kUGFuZWwgPSB1c2VDYWxsYmFjaygocGFuZWxEYXRhLCBtaW5TaXplT3ZlcnJpZGUpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvbkxheW91dFxuICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBsYXlvdXQ6IHByZXZMYXlvdXQsXG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGlmIChwYW5lbERhdGEuY29uc3RyYWludHMuY29sbGFwc2libGUpIHtcbiAgICAgIGNvbnN0IHBhbmVsQ29uc3RyYWludHNBcnJheSA9IHBhbmVsRGF0YUFycmF5Lm1hcChwYW5lbERhdGEgPT4gcGFuZWxEYXRhLmNvbnN0cmFpbnRzKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICAgIHBhbmVsU2l6ZSA9IDAsXG4gICAgICAgIG1pblNpemU6IG1pblNpemVGcm9tUHJvcHMgPSAwLFxuICAgICAgICBwaXZvdEluZGljZXNcbiAgICAgIH0gPSBwYW5lbERhdGFIZWxwZXIocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSwgcHJldkxheW91dCk7XG4gICAgICBjb25zdCBtaW5TaXplID0gbWluU2l6ZU92ZXJyaWRlICE9PSBudWxsICYmIG1pblNpemVPdmVycmlkZSAhPT0gdm9pZCAwID8gbWluU2l6ZU92ZXJyaWRlIDogbWluU2l6ZUZyb21Qcm9wcztcbiAgICAgIGlmIChmdXp6eU51bWJlcnNFcXVhbCQxKHBhbmVsU2l6ZSwgY29sbGFwc2VkU2l6ZSkpIHtcbiAgICAgICAgLy8gUmVzdG9yZSB0aGlzIHBhbmVsIHRvIHRoZSBzaXplIGl0IHdhcyBiZWZvcmUgaXQgd2FzIGNvbGxhcHNlZCwgaWYgcG9zc2libGUuXG4gICAgICAgIGNvbnN0IHByZXZQYW5lbFNpemUgPSBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZVJlZi5jdXJyZW50LmdldChwYW5lbERhdGEuaWQpO1xuICAgICAgICBjb25zdCBiYXNlU2l6ZSA9IHByZXZQYW5lbFNpemUgIT0gbnVsbCAmJiBwcmV2UGFuZWxTaXplID49IG1pblNpemUgPyBwcmV2UGFuZWxTaXplIDogbWluU2l6ZTtcbiAgICAgICAgY29uc3QgaXNMYXN0UGFuZWwgPSBmaW5kUGFuZWxEYXRhSW5kZXgocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSkgPT09IHBhbmVsRGF0YUFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gaXNMYXN0UGFuZWwgPyBwYW5lbFNpemUgLSBiYXNlU2l6ZSA6IGJhc2VTaXplIC0gcGFuZWxTaXplO1xuICAgICAgICBjb25zdCBuZXh0TGF5b3V0ID0gYWRqdXN0TGF5b3V0QnlEZWx0YSh7XG4gICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgaW5pdGlhbExheW91dDogcHJldkxheW91dCxcbiAgICAgICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gICAgICAgICAgcGl2b3RJbmRpY2VzLFxuICAgICAgICAgIHByZXZMYXlvdXQsXG4gICAgICAgICAgdHJpZ2dlcjogXCJpbXBlcmF0aXZlLWFwaVwiXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNvbXBhcmVMYXlvdXRzKHByZXZMYXlvdXQsIG5leHRMYXlvdXQpKSB7XG4gICAgICAgICAgc2V0TGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICAgIGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQubGF5b3V0ID0gbmV4dExheW91dDtcbiAgICAgICAgICBpZiAob25MYXlvdXQpIHtcbiAgICAgICAgICAgIG9uTGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxEYXRhQXJyYXksIG5leHRMYXlvdXQsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBFeHRlcm5hbCBBUElzIGFyZSBzYWZlIHRvIG1lbW9pemUgdmlhIGNvbW1pdHRlZCB2YWx1ZXMgcmVmXG4gIGNvbnN0IGdldFBhbmVsU2l6ZSA9IHVzZUNhbGxiYWNrKHBhbmVsRGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbGF5b3V0LFxuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBwYW5lbFNpemVcbiAgICB9ID0gcGFuZWxEYXRhSGVscGVyKHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEsIGxheW91dCk7XG4gICAgYXNzZXJ0KHBhbmVsU2l6ZSAhPSBudWxsLCBgUGFuZWwgc2l6ZSBub3QgZm91bmQgZm9yIHBhbmVsIFwiJHtwYW5lbERhdGEuaWR9XCJgKTtcbiAgICByZXR1cm4gcGFuZWxTaXplO1xuICB9LCBbXSk7XG5cbiAgLy8gVGhpcyBBUEkgc2hvdWxkIG5ldmVyIHJlYWQgZnJvbSBjb21taXR0ZWRWYWx1ZXNSZWZcbiAgY29uc3QgZ2V0UGFuZWxTdHlsZSA9IHVzZUNhbGxiYWNrKChwYW5lbERhdGEsIGRlZmF1bHRTaXplKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBwYW5lbEluZGV4ID0gZmluZFBhbmVsRGF0YUluZGV4KHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEpO1xuICAgIHJldHVybiBjb21wdXRlUGFuZWxGbGV4Qm94U3R5bGUoe1xuICAgICAgZGVmYXVsdFNpemUsXG4gICAgICBkcmFnU3RhdGUsXG4gICAgICBsYXlvdXQsXG4gICAgICBwYW5lbERhdGE6IHBhbmVsRGF0YUFycmF5LFxuICAgICAgcGFuZWxJbmRleFxuICAgIH0pO1xuICB9LCBbZHJhZ1N0YXRlLCBsYXlvdXRdKTtcblxuICAvLyBFeHRlcm5hbCBBUElzIGFyZSBzYWZlIHRvIG1lbW9pemUgdmlhIGNvbW1pdHRlZCB2YWx1ZXMgcmVmXG4gIGNvbnN0IGlzUGFuZWxDb2xsYXBzZWQgPSB1c2VDYWxsYmFjayhwYW5lbERhdGEgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGxheW91dCxcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICBjb2xsYXBzaWJsZSxcbiAgICAgIHBhbmVsU2l6ZVxuICAgIH0gPSBwYW5lbERhdGFIZWxwZXIocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSwgbGF5b3V0KTtcbiAgICBhc3NlcnQocGFuZWxTaXplICE9IG51bGwsIGBQYW5lbCBzaXplIG5vdCBmb3VuZCBmb3IgcGFuZWwgXCIke3BhbmVsRGF0YS5pZH1cImApO1xuICAgIHJldHVybiBjb2xsYXBzaWJsZSA9PT0gdHJ1ZSAmJiBmdXp6eU51bWJlcnNFcXVhbCQxKHBhbmVsU2l6ZSwgY29sbGFwc2VkU2l6ZSk7XG4gIH0sIFtdKTtcblxuICAvLyBFeHRlcm5hbCBBUElzIGFyZSBzYWZlIHRvIG1lbW9pemUgdmlhIGNvbW1pdHRlZCB2YWx1ZXMgcmVmXG4gIGNvbnN0IGlzUGFuZWxFeHBhbmRlZCA9IHVzZUNhbGxiYWNrKHBhbmVsRGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbGF5b3V0LFxuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBjb2xsYXBzZWRTaXplID0gMCxcbiAgICAgIGNvbGxhcHNpYmxlLFxuICAgICAgcGFuZWxTaXplXG4gICAgfSA9IHBhbmVsRGF0YUhlbHBlcihwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhLCBsYXlvdXQpO1xuICAgIGFzc2VydChwYW5lbFNpemUgIT0gbnVsbCwgYFBhbmVsIHNpemUgbm90IGZvdW5kIGZvciBwYW5lbCBcIiR7cGFuZWxEYXRhLmlkfVwiYCk7XG4gICAgcmV0dXJuICFjb2xsYXBzaWJsZSB8fCBmdXp6eUNvbXBhcmVOdW1iZXJzKHBhbmVsU2l6ZSwgY29sbGFwc2VkU2l6ZSkgPiAwO1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlZ2lzdGVyUGFuZWwgPSB1c2VDYWxsYmFjayhwYW5lbERhdGEgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgcGFuZWxEYXRhQXJyYXkucHVzaChwYW5lbERhdGEpO1xuICAgIHBhbmVsRGF0YUFycmF5LnNvcnQoKHBhbmVsQSwgcGFuZWxCKSA9PiB7XG4gICAgICBjb25zdCBvcmRlckEgPSBwYW5lbEEub3JkZXI7XG4gICAgICBjb25zdCBvcmRlckIgPSBwYW5lbEIub3JkZXI7XG4gICAgICBpZiAob3JkZXJBID09IG51bGwgJiYgb3JkZXJCID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKG9yZGVyQSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAob3JkZXJCID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3JkZXJBIC0gb3JkZXJCO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQucGFuZWxEYXRhQXJyYXlDaGFuZ2VkID0gdHJ1ZTtcbiAgfSwgW10pO1xuICBjb25zdCByZWdpc3RlclJlc2l6ZUhhbmRsZSA9IHVzZUNhbGxiYWNrKGRyYWdIYW5kbGVJZCA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlc2l6ZUhhbmRsZXIoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBwYW5lbEdyb3VwRWxlbWVudCA9IHBhbmVsR3JvdXBFbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIXBhbmVsR3JvdXBFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIGRyYWdTdGF0ZSxcbiAgICAgICAgaWQ6IGdyb3VwSWQsXG4gICAgICAgIGtleWJvYXJkUmVzaXplQnksXG4gICAgICAgIG9uTGF5b3V0XG4gICAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxheW91dDogcHJldkxheW91dCxcbiAgICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBpbml0aWFsTGF5b3V0XG4gICAgICB9ID0gZHJhZ1N0YXRlICE9PSBudWxsICYmIGRyYWdTdGF0ZSAhPT0gdm9pZCAwID8gZHJhZ1N0YXRlIDoge307XG4gICAgICBjb25zdCBwaXZvdEluZGljZXMgPSBkZXRlcm1pbmVQaXZvdEluZGljZXMoZ3JvdXBJZCwgZHJhZ0hhbmRsZUlkLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gICAgICBsZXQgZGVsdGEgPSBjYWxjdWxhdGVEZWx0YVBlcmNlbnRhZ2UoZXZlbnQsIGRyYWdIYW5kbGVJZCwgZGlyZWN0aW9uLCBkcmFnU3RhdGUsIGtleWJvYXJkUmVzaXplQnksIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFN1cHBvcnQgUlRMIGxheW91dHNcbiAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gICAgICBpZiAoZG9jdW1lbnQuZGlyID09PSBcInJ0bFwiICYmIGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBkZWx0YSA9IC1kZWx0YTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhbmVsQ29uc3RyYWludHMgPSBwYW5lbERhdGFBcnJheS5tYXAocGFuZWxEYXRhID0+IHBhbmVsRGF0YS5jb25zdHJhaW50cyk7XG4gICAgICBjb25zdCBuZXh0TGF5b3V0ID0gYWRqdXN0TGF5b3V0QnlEZWx0YSh7XG4gICAgICAgIGRlbHRhLFxuICAgICAgICBpbml0aWFsTGF5b3V0OiBpbml0aWFsTGF5b3V0ICE9PSBudWxsICYmIGluaXRpYWxMYXlvdXQgIT09IHZvaWQgMCA/IGluaXRpYWxMYXlvdXQgOiBwcmV2TGF5b3V0LFxuICAgICAgICBwYW5lbENvbnN0cmFpbnRzLFxuICAgICAgICBwaXZvdEluZGljZXMsXG4gICAgICAgIHByZXZMYXlvdXQsXG4gICAgICAgIHRyaWdnZXI6IGlzS2V5RG93bihldmVudCkgPyBcImtleWJvYXJkXCIgOiBcIm1vdXNlLW9yLXRvdWNoXCJcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbGF5b3V0Q2hhbmdlZCA9ICFjb21wYXJlTGF5b3V0cyhwcmV2TGF5b3V0LCBuZXh0TGF5b3V0KTtcblxuICAgICAgLy8gT25seSB1cGRhdGUgdGhlIGN1cnNvciBmb3IgbGF5b3V0IGNoYW5nZXMgdHJpZ2dlcmVkIGJ5IHRvdWNoL21vdXNlIGV2ZW50cyAobm90IGtleWJvYXJkKVxuICAgICAgLy8gVXBkYXRlIHRoZSBjdXJzb3IgZXZlbiBpZiB0aGUgbGF5b3V0IGhhc24ndCBjaGFuZ2VkICh3ZSBtYXkgbmVlZCB0byBzaG93IGFuIGludmFsaWQgY3Vyc29yIHN0YXRlKVxuICAgICAgaWYgKGlzUG9pbnRlckV2ZW50KGV2ZW50KSB8fCBpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIC8vIFdhdGNoIGZvciBtdWx0aXBsZSBzdWJzZXF1ZW50IGRlbHRhczsgdGhpcyBtaWdodCBvY2N1ciBmb3IgdGlueSBjdXJzb3IgbW92ZW1lbnRzLlxuICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIFBhbmVsIHNpemVzIG1pZ2h0IG5vdCBjaGFuZ2XigJNcbiAgICAgICAgLy8gYnV0IHVwZGF0aW5nIGN1cnNvciBpbiB0aGlzIHNjZW5hcmlvIHdvdWxkIGNhdXNlIGEgZmxpY2tlci5cbiAgICAgICAgaWYgKHByZXZEZWx0YVJlZi5jdXJyZW50ICE9IGRlbHRhKSB7XG4gICAgICAgICAgcHJldkRlbHRhUmVmLmN1cnJlbnQgPSBkZWx0YTtcbiAgICAgICAgICBpZiAoIWxheW91dENoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwb2ludGVyIGhhcyBtb3ZlZCB0b28gZmFyIHRvIHJlc2l6ZSB0aGUgcGFuZWwgYW55IGZ1cnRoZXIsIG5vdGUgdGhpcyBzbyB3ZSBjYW4gdXBkYXRlIHRoZSBjdXJzb3IuXG4gICAgICAgICAgICAvLyBUaGlzIG1pbWljcyBWUyBDb2RlIGJlaGF2aW9yLlxuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICByZXBvcnRDb25zdHJhaW50c1Zpb2xhdGlvbihkcmFnSGFuZGxlSWQsIGRlbHRhIDwgMCA/IEVYQ0VFREVEX0hPUklaT05UQUxfTUlOIDogRVhDRUVERURfSE9SSVpPTlRBTF9NQVgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVwb3J0Q29uc3RyYWludHNWaW9sYXRpb24oZHJhZ0hhbmRsZUlkLCBkZWx0YSA8IDAgPyBFWENFRURFRF9WRVJUSUNBTF9NSU4gOiBFWENFRURFRF9WRVJUSUNBTF9NQVgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBvcnRDb25zdHJhaW50c1Zpb2xhdGlvbihkcmFnSGFuZGxlSWQsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxheW91dENoYW5nZWQpIHtcbiAgICAgICAgc2V0TGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICBlYWdlclZhbHVlc1JlZi5jdXJyZW50LmxheW91dCA9IG5leHRMYXlvdXQ7XG4gICAgICAgIGlmIChvbkxheW91dCkge1xuICAgICAgICAgIG9uTGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbERhdGFBcnJheSwgbmV4dExheW91dCwgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gRXh0ZXJuYWwgQVBJcyBhcmUgc2FmZSB0byBtZW1vaXplIHZpYSBjb21taXR0ZWQgdmFsdWVzIHJlZlxuICBjb25zdCByZXNpemVQYW5lbCA9IHVzZUNhbGxiYWNrKChwYW5lbERhdGEsIHVuc2FmZVBhbmVsU2l6ZSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uTGF5b3V0XG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGxheW91dDogcHJldkxheW91dCxcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgcGFuZWxDb25zdHJhaW50c0FycmF5ID0gcGFuZWxEYXRhQXJyYXkubWFwKHBhbmVsRGF0YSA9PiBwYW5lbERhdGEuY29uc3RyYWludHMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVsU2l6ZSxcbiAgICAgIHBpdm90SW5kaWNlc1xuICAgIH0gPSBwYW5lbERhdGFIZWxwZXIocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSwgcHJldkxheW91dCk7XG4gICAgYXNzZXJ0KHBhbmVsU2l6ZSAhPSBudWxsLCBgUGFuZWwgc2l6ZSBub3QgZm91bmQgZm9yIHBhbmVsIFwiJHtwYW5lbERhdGEuaWR9XCJgKTtcbiAgICBjb25zdCBpc0xhc3RQYW5lbCA9IGZpbmRQYW5lbERhdGFJbmRleChwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhKSA9PT0gcGFuZWxEYXRhQXJyYXkubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBkZWx0YSA9IGlzTGFzdFBhbmVsID8gcGFuZWxTaXplIC0gdW5zYWZlUGFuZWxTaXplIDogdW5zYWZlUGFuZWxTaXplIC0gcGFuZWxTaXplO1xuICAgIGNvbnN0IG5leHRMYXlvdXQgPSBhZGp1c3RMYXlvdXRCeURlbHRhKHtcbiAgICAgIGRlbHRhLFxuICAgICAgaW5pdGlhbExheW91dDogcHJldkxheW91dCxcbiAgICAgIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgICAgIHBpdm90SW5kaWNlcyxcbiAgICAgIHByZXZMYXlvdXQsXG4gICAgICB0cmlnZ2VyOiBcImltcGVyYXRpdmUtYXBpXCJcbiAgICB9KTtcbiAgICBpZiAoIWNvbXBhcmVMYXlvdXRzKHByZXZMYXlvdXQsIG5leHRMYXlvdXQpKSB7XG4gICAgICBzZXRMYXlvdXQobmV4dExheW91dCk7XG4gICAgICBlYWdlclZhbHVlc1JlZi5jdXJyZW50LmxheW91dCA9IG5leHRMYXlvdXQ7XG4gICAgICBpZiAob25MYXlvdXQpIHtcbiAgICAgICAgb25MYXlvdXQobmV4dExheW91dCk7XG4gICAgICB9XG4gICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxEYXRhQXJyYXksIG5leHRMYXlvdXQsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudCk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHJlZXZhbHVhdGVQYW5lbENvbnN0cmFpbnRzID0gdXNlQ2FsbGJhY2soKHBhbmVsRGF0YSwgcHJldkNvbnN0cmFpbnRzKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbGF5b3V0LFxuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBjb2xsYXBzZWRTaXplOiBwcmV2Q29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICBjb2xsYXBzaWJsZTogcHJldkNvbGxhcHNpYmxlXG4gICAgfSA9IHByZXZDb25zdHJhaW50cztcbiAgICBjb25zdCB7XG4gICAgICBjb2xsYXBzZWRTaXplOiBuZXh0Q29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICBjb2xsYXBzaWJsZTogbmV4dENvbGxhcHNpYmxlLFxuICAgICAgbWF4U2l6ZTogbmV4dE1heFNpemUgPSAxMDAsXG4gICAgICBtaW5TaXplOiBuZXh0TWluU2l6ZSA9IDBcbiAgICB9ID0gcGFuZWxEYXRhLmNvbnN0cmFpbnRzO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVsU2l6ZTogcHJldlBhbmVsU2l6ZVxuICAgIH0gPSBwYW5lbERhdGFIZWxwZXIocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSwgbGF5b3V0KTtcbiAgICBpZiAocHJldlBhbmVsU2l6ZSA9PSBudWxsKSB7XG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHBhbmVscyBpbiB0aGlzIGdyb3VwIGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCByZW5kZXJcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByZXZDb2xsYXBzaWJsZSAmJiBuZXh0Q29sbGFwc2libGUgJiYgZnV6enlOdW1iZXJzRXF1YWwkMShwcmV2UGFuZWxTaXplLCBwcmV2Q29sbGFwc2VkU2l6ZSkpIHtcbiAgICAgIGlmICghZnV6enlOdW1iZXJzRXF1YWwkMShwcmV2Q29sbGFwc2VkU2l6ZSwgbmV4dENvbGxhcHNlZFNpemUpKSB7XG4gICAgICAgIHJlc2l6ZVBhbmVsKHBhbmVsRGF0YSwgbmV4dENvbGxhcHNlZFNpemUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldlBhbmVsU2l6ZSA8IG5leHRNaW5TaXplKSB7XG4gICAgICByZXNpemVQYW5lbChwYW5lbERhdGEsIG5leHRNaW5TaXplKTtcbiAgICB9IGVsc2UgaWYgKHByZXZQYW5lbFNpemUgPiBuZXh0TWF4U2l6ZSkge1xuICAgICAgcmVzaXplUGFuZWwocGFuZWxEYXRhLCBuZXh0TWF4U2l6ZSk7XG4gICAgfVxuICB9LCBbcmVzaXplUGFuZWxdKTtcbiAgY29uc3Qgc3RhcnREcmFnZ2luZyA9IHVzZUNhbGxiYWNrKChkcmFnSGFuZGxlSWQsIGV2ZW50KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZGlyZWN0aW9uXG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGxheW91dFxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGlmICghcGFuZWxHcm91cEVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVFbGVtZW50ID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudChkcmFnSGFuZGxlSWQsIHBhbmVsR3JvdXBFbGVtZW50UmVmLmN1cnJlbnQpO1xuICAgIGFzc2VydChoYW5kbGVFbGVtZW50LCBgRHJhZyBoYW5kbGUgZWxlbWVudCBub3QgZm91bmQgZm9yIGlkIFwiJHtkcmFnSGFuZGxlSWR9XCJgKTtcbiAgICBjb25zdCBpbml0aWFsQ3Vyc29yUG9zaXRpb24gPSBnZXRSZXNpemVFdmVudEN1cnNvclBvc2l0aW9uKGRpcmVjdGlvbiwgZXZlbnQpO1xuICAgIHNldERyYWdTdGF0ZSh7XG4gICAgICBkcmFnSGFuZGxlSWQsXG4gICAgICBkcmFnSGFuZGxlUmVjdDogaGFuZGxlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGluaXRpYWxDdXJzb3JQb3NpdGlvbixcbiAgICAgIGluaXRpYWxMYXlvdXQ6IGxheW91dFxuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHN0b3BEcmFnZ2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXREcmFnU3RhdGUobnVsbCk7XG4gIH0sIFtdKTtcbiAgY29uc3QgdW5yZWdpc3RlclBhbmVsID0gdXNlQ2FsbGJhY2socGFuZWxEYXRhID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGluZGV4ID0gZmluZFBhbmVsRGF0YUluZGV4KHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBwYW5lbERhdGFBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAvLyBUUklDS1lcbiAgICAgIC8vIFdoZW4gYSBwYW5lbCBpcyByZW1vdmVkIGZyb20gdGhlIGdyb3VwLCB3ZSBzaG91bGQgZGVsZXRlIHRoZSBtb3N0IHJlY2VudCBwcmV2LXNpemUgZW50cnkgZm9yIGl0LlxuICAgICAgLy8gSWYgd2UgZG9uJ3QgZG8gdGhpcywgdGhlbiBhIGNvbmRpdGlvbmFsbHkgcmVuZGVyZWQgcGFuZWwgbWlnaHQgbm90IGNhbGwgb25SZXNpemUgd2hlbiBpdCdzIHJlLW1vdW50ZWQuXG4gICAgICAvLyBTdHJpY3QgZWZmZWN0cyBtb2RlIG1ha2VzIHRoaXMgdHJpY2t5IHRob3VnaCBiZWNhdXNlIGFsbCBwYW5lbHMgd2lsbCBiZSByZWdpc3RlcmVkLCB1bnJlZ2lzdGVyZWQsIHRoZW4gcmUtcmVnaXN0ZXJlZCBvbiBtb3VudC5cbiAgICAgIGRlbGV0ZSBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmLmN1cnJlbnRbcGFuZWxEYXRhLmlkXTtcbiAgICAgIGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQucGFuZWxEYXRhQXJyYXlDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjb2xsYXBzZVBhbmVsLFxuICAgIGRpcmVjdGlvbixcbiAgICBkcmFnU3RhdGUsXG4gICAgZXhwYW5kUGFuZWwsXG4gICAgZ2V0UGFuZWxTaXplLFxuICAgIGdldFBhbmVsU3R5bGUsXG4gICAgZ3JvdXBJZCxcbiAgICBpc1BhbmVsQ29sbGFwc2VkLFxuICAgIGlzUGFuZWxFeHBhbmRlZCxcbiAgICByZWV2YWx1YXRlUGFuZWxDb25zdHJhaW50cyxcbiAgICByZWdpc3RlclBhbmVsLFxuICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlLFxuICAgIHJlc2l6ZVBhbmVsLFxuICAgIHN0YXJ0RHJhZ2dpbmcsXG4gICAgc3RvcERyYWdnaW5nLFxuICAgIHVucmVnaXN0ZXJQYW5lbCxcbiAgICBwYW5lbEdyb3VwRWxlbWVudDogcGFuZWxHcm91cEVsZW1lbnRSZWYuY3VycmVudFxuICB9KSwgW2NvbGxhcHNlUGFuZWwsIGRyYWdTdGF0ZSwgZGlyZWN0aW9uLCBleHBhbmRQYW5lbCwgZ2V0UGFuZWxTaXplLCBnZXRQYW5lbFN0eWxlLCBncm91cElkLCBpc1BhbmVsQ29sbGFwc2VkLCBpc1BhbmVsRXhwYW5kZWQsIHJlZXZhbHVhdGVQYW5lbENvbnN0cmFpbnRzLCByZWdpc3RlclBhbmVsLCByZWdpc3RlclJlc2l6ZUhhbmRsZSwgcmVzaXplUGFuZWwsIHN0YXJ0RHJhZ2dpbmcsIHN0b3BEcmFnZ2luZywgdW5yZWdpc3RlclBhbmVsXSk7XG4gIGNvbnN0IHN0eWxlID0ge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGZsZXhEaXJlY3Rpb246IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcInJvd1wiIDogXCJjb2x1bW5cIixcbiAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgIHdpZHRoOiBcIjEwMCVcIlxuICB9O1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChQYW5lbEdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIGNyZWF0ZUVsZW1lbnQoVHlwZSwge1xuICAgIC4uLnJlc3QsXG4gICAgY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMsXG4gICAgaWQ6IGlkRnJvbVByb3BzLFxuICAgIHJlZjogcGFuZWxHcm91cEVsZW1lbnRSZWYsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgLi4uc3R5bGVGcm9tUHJvcHNcbiAgICB9LFxuICAgIC8vIENTUyBzZWxlY3RvcnNcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXBcIjogXCJcIixcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtZGlyZWN0aW9uXCI6IGRpcmVjdGlvbixcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtaWRcIjogZ3JvdXBJZFxuICB9KSk7XG59XG5jb25zdCBQYW5lbEdyb3VwID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gY3JlYXRlRWxlbWVudChQYW5lbEdyb3VwV2l0aEZvcndhcmRlZFJlZiwge1xuICAuLi5wcm9wcyxcbiAgZm9yd2FyZGVkUmVmOiByZWZcbn0pKTtcblBhbmVsR3JvdXBXaXRoRm9yd2FyZGVkUmVmLmRpc3BsYXlOYW1lID0gXCJQYW5lbEdyb3VwXCI7XG5QYW5lbEdyb3VwLmRpc3BsYXlOYW1lID0gXCJmb3J3YXJkUmVmKFBhbmVsR3JvdXApXCI7XG5mdW5jdGlvbiBmaW5kUGFuZWxEYXRhSW5kZXgocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSkge1xuICByZXR1cm4gcGFuZWxEYXRhQXJyYXkuZmluZEluZGV4KHByZXZQYW5lbERhdGEgPT4gcHJldlBhbmVsRGF0YSA9PT0gcGFuZWxEYXRhIHx8IHByZXZQYW5lbERhdGEuaWQgPT09IHBhbmVsRGF0YS5pZCk7XG59XG5mdW5jdGlvbiBwYW5lbERhdGFIZWxwZXIocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSwgbGF5b3V0KSB7XG4gIGNvbnN0IHBhbmVsSW5kZXggPSBmaW5kUGFuZWxEYXRhSW5kZXgocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSk7XG4gIGNvbnN0IGlzTGFzdFBhbmVsID0gcGFuZWxJbmRleCA9PT0gcGFuZWxEYXRhQXJyYXkubGVuZ3RoIC0gMTtcbiAgY29uc3QgcGl2b3RJbmRpY2VzID0gaXNMYXN0UGFuZWwgPyBbcGFuZWxJbmRleCAtIDEsIHBhbmVsSW5kZXhdIDogW3BhbmVsSW5kZXgsIHBhbmVsSW5kZXggKyAxXTtcbiAgY29uc3QgcGFuZWxTaXplID0gbGF5b3V0W3BhbmVsSW5kZXhdO1xuICByZXR1cm4ge1xuICAgIC4uLnBhbmVsRGF0YS5jb25zdHJhaW50cyxcbiAgICBwYW5lbFNpemUsXG4gICAgcGl2b3RJbmRpY2VzXG4gIH07XG59XG5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvd2luZG93c3BsaXR0ZXIvXG5cbmZ1bmN0aW9uIHVzZVdpbmRvd1NwbGl0dGVyUmVzaXplSGFuZGxlckJlaGF2aW9yKHtcbiAgZGlzYWJsZWQsXG4gIGhhbmRsZUlkLFxuICByZXNpemVIYW5kbGVyLFxuICBwYW5lbEdyb3VwRWxlbWVudFxufSkge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCByZXNpemVIYW5kbGVyID09IG51bGwgfHwgcGFuZWxHcm91cEVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVFbGVtZW50ID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudChoYW5kbGVJZCwgcGFuZWxHcm91cEVsZW1lbnQpO1xuICAgIGlmIChoYW5kbGVFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb25LZXlEb3duID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XG4gICAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgIGNhc2UgXCJFbmRcIjpcbiAgICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmVzaXplSGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJGNlwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBjb25zdCBncm91cElkID0gaGFuZGxlRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBhbmVsLWdyb3VwLWlkXCIpO1xuICAgICAgICAgICAgYXNzZXJ0KGdyb3VwSWQsIGBObyBncm91cCBlbGVtZW50IGZvdW5kIGZvciBpZCBcIiR7Z3JvdXBJZH1cImApO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlcyA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRzRm9yR3JvdXAoZ3JvdXBJZCwgcGFuZWxHcm91cEVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRSZXNpemVIYW5kbGVFbGVtZW50SW5kZXgoZ3JvdXBJZCwgaGFuZGxlSWQsIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgICAgICAgICAgIGFzc2VydChpbmRleCAhPT0gbnVsbCwgYE5vIHJlc2l6ZSBlbGVtZW50IGZvdW5kIGZvciBpZCBcIiR7aGFuZGxlSWR9XCJgKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IGV2ZW50LnNoaWZ0S2V5ID8gaW5kZXggPiAwID8gaW5kZXggLSAxIDogaGFuZGxlcy5sZW5ndGggLSAxIDogaW5kZXggKyAxIDwgaGFuZGxlcy5sZW5ndGggPyBpbmRleCArIDEgOiAwO1xuICAgICAgICAgICAgY29uc3QgbmV4dEhhbmRsZSA9IGhhbmRsZXNbbmV4dEluZGV4XTtcbiAgICAgICAgICAgIG5leHRIYW5kbGUuZm9jdXMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGhhbmRsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaGFuZGxlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgIH07XG4gIH0sIFtwYW5lbEdyb3VwRWxlbWVudCwgZGlzYWJsZWQsIGhhbmRsZUlkLCByZXNpemVIYW5kbGVyXSk7XG59XG5cbmZ1bmN0aW9uIFBhbmVsUmVzaXplSGFuZGxlKHtcbiAgY2hpbGRyZW4gPSBudWxsLFxuICBjbGFzc05hbWU6IGNsYXNzTmFtZUZyb21Qcm9wcyA9IFwiXCIsXG4gIGRpc2FibGVkID0gZmFsc2UsXG4gIGhpdEFyZWFNYXJnaW5zLFxuICBpZDogaWRGcm9tUHJvcHMsXG4gIG9uQmx1cixcbiAgb25EcmFnZ2luZyxcbiAgb25Gb2N1cyxcbiAgc3R5bGU6IHN0eWxlRnJvbVByb3BzID0ge30sXG4gIHRhYkluZGV4ID0gMCxcbiAgdGFnTmFtZTogVHlwZSA9IFwiZGl2XCIsXG4gIC4uLnJlc3Rcbn0pIHtcbiAgdmFyIF9oaXRBcmVhTWFyZ2lucyRjb2FycywgX2hpdEFyZWFNYXJnaW5zJGZpbmU7XG4gIGNvbnN0IGVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgLy8gVXNlIGEgcmVmIHRvIGd1YXJkIGFnYWluc3QgdXNlcnMgcGFzc2luZyBpbmxpbmUgcHJvcHNcbiAgY29uc3QgY2FsbGJhY2tzUmVmID0gdXNlUmVmKHtcbiAgICBvbkRyYWdnaW5nXG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNhbGxiYWNrc1JlZi5jdXJyZW50Lm9uRHJhZ2dpbmcgPSBvbkRyYWdnaW5nO1xuICB9KTtcbiAgY29uc3QgcGFuZWxHcm91cENvbnRleHQgPSB1c2VDb250ZXh0KFBhbmVsR3JvdXBDb250ZXh0KTtcbiAgaWYgKHBhbmVsR3JvdXBDb250ZXh0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgRXJyb3IoYFBhbmVsUmVzaXplSGFuZGxlIGNvbXBvbmVudHMgbXVzdCBiZSByZW5kZXJlZCB3aXRoaW4gYSBQYW5lbEdyb3VwIGNvbnRhaW5lcmApO1xuICB9XG4gIGNvbnN0IHtcbiAgICBkaXJlY3Rpb24sXG4gICAgZ3JvdXBJZCxcbiAgICByZWdpc3RlclJlc2l6ZUhhbmRsZTogcmVnaXN0ZXJSZXNpemVIYW5kbGVXaXRoUGFyZW50R3JvdXAsXG4gICAgc3RhcnREcmFnZ2luZyxcbiAgICBzdG9wRHJhZ2dpbmcsXG4gICAgcGFuZWxHcm91cEVsZW1lbnRcbiAgfSA9IHBhbmVsR3JvdXBDb250ZXh0O1xuICBjb25zdCByZXNpemVIYW5kbGVJZCA9IHVzZVVuaXF1ZUlkKGlkRnJvbVByb3BzKTtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZShcImluYWN0aXZlXCIpO1xuICBjb25zdCBbaXNGb2N1c2VkLCBzZXRJc0ZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbcmVzaXplSGFuZGxlciwgc2V0UmVzaXplSGFuZGxlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgY29tbWl0dGVkVmFsdWVzUmVmID0gdXNlUmVmKHtcbiAgICBzdGF0ZVxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHNldFJlc2l6ZUhhbmRsZXIobnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc2l6ZUhhbmRsZXIgPSByZWdpc3RlclJlc2l6ZUhhbmRsZVdpdGhQYXJlbnRHcm91cChyZXNpemVIYW5kbGVJZCk7XG4gICAgICBzZXRSZXNpemVIYW5kbGVyKCgpID0+IHJlc2l6ZUhhbmRsZXIpO1xuICAgIH1cbiAgfSwgW2Rpc2FibGVkLCByZXNpemVIYW5kbGVJZCwgcmVnaXN0ZXJSZXNpemVIYW5kbGVXaXRoUGFyZW50R3JvdXBdKTtcblxuICAvLyBFeHRyYWN0IGhpdCBhcmVhIG1hcmdpbnMgYmVmb3JlIHBhc3NpbmcgdGhlbSB0byB0aGUgZWZmZWN0J3MgZGVwZW5kZW5jeSBhcnJheVxuICAvLyBzbyB0aGF0IGlubGluZSBvYmplY3QgdmFsdWVzIHdvbid0IHRyaWdnZXIgcmUtcmVuZGVyc1xuICBjb25zdCBjb2Fyc2VIaXRBcmVhTWFyZ2lucyA9IChfaGl0QXJlYU1hcmdpbnMkY29hcnMgPSBoaXRBcmVhTWFyZ2lucyA9PT0gbnVsbCB8fCBoaXRBcmVhTWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGl0QXJlYU1hcmdpbnMuY29hcnNlKSAhPT0gbnVsbCAmJiBfaGl0QXJlYU1hcmdpbnMkY29hcnMgIT09IHZvaWQgMCA/IF9oaXRBcmVhTWFyZ2lucyRjb2FycyA6IDE1O1xuICBjb25zdCBmaW5lSGl0QXJlYU1hcmdpbnMgPSAoX2hpdEFyZWFNYXJnaW5zJGZpbmUgPSBoaXRBcmVhTWFyZ2lucyA9PT0gbnVsbCB8fCBoaXRBcmVhTWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGl0QXJlYU1hcmdpbnMuZmluZSkgIT09IG51bGwgJiYgX2hpdEFyZWFNYXJnaW5zJGZpbmUgIT09IHZvaWQgMCA/IF9oaXRBcmVhTWFyZ2lucyRmaW5lIDogNTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgcmVzaXplSGFuZGxlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgYXNzZXJ0KGVsZW1lbnQsIFwiRWxlbWVudCByZWYgbm90IGF0dGFjaGVkXCIpO1xuICAgIGNvbnN0IHNldFJlc2l6ZUhhbmRsZXJTdGF0ZSA9IChhY3Rpb24sIGlzQWN0aXZlLCBldmVudCkgPT4ge1xuICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgY2FzZSBcImRvd25cIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2V0U3RhdGUoXCJkcmFnXCIpO1xuICAgICAgICAgICAgICBzdGFydERyYWdnaW5nKHJlc2l6ZUhhbmRsZUlkLCBldmVudCk7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nXG4gICAgICAgICAgICAgIH0gPSBjYWxsYmFja3NSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgaWYgKG9uRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nKHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJtb3ZlXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gXCJkcmFnXCIpIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZShcImhvdmVyXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc2l6ZUhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidXBcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2V0U3RhdGUoXCJob3ZlclwiKTtcbiAgICAgICAgICAgICAgc3RvcERyYWdnaW5nKCk7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nXG4gICAgICAgICAgICAgIH0gPSBjYWxsYmFja3NSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgaWYgKG9uRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U3RhdGUoXCJpbmFjdGl2ZVwiKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByZWdpc3RlclJlc2l6ZUhhbmRsZShyZXNpemVIYW5kbGVJZCwgZWxlbWVudCwgZGlyZWN0aW9uLCB7XG4gICAgICBjb2Fyc2U6IGNvYXJzZUhpdEFyZWFNYXJnaW5zLFxuICAgICAgZmluZTogZmluZUhpdEFyZWFNYXJnaW5zXG4gICAgfSwgc2V0UmVzaXplSGFuZGxlclN0YXRlKTtcbiAgfSwgW2NvYXJzZUhpdEFyZWFNYXJnaW5zLCBkaXJlY3Rpb24sIGRpc2FibGVkLCBmaW5lSGl0QXJlYU1hcmdpbnMsIHJlZ2lzdGVyUmVzaXplSGFuZGxlV2l0aFBhcmVudEdyb3VwLCByZXNpemVIYW5kbGVJZCwgcmVzaXplSGFuZGxlciwgc3RhcnREcmFnZ2luZywgc3RvcERyYWdnaW5nXSk7XG4gIHVzZVdpbmRvd1NwbGl0dGVyUmVzaXplSGFuZGxlckJlaGF2aW9yKHtcbiAgICBkaXNhYmxlZCxcbiAgICBoYW5kbGVJZDogcmVzaXplSGFuZGxlSWQsXG4gICAgcmVzaXplSGFuZGxlcixcbiAgICBwYW5lbEdyb3VwRWxlbWVudFxuICB9KTtcbiAgY29uc3Qgc3R5bGUgPSB7XG4gICAgdG91Y2hBY3Rpb246IFwibm9uZVwiLFxuICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiXG4gIH07XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFR5cGUsIHtcbiAgICAuLi5yZXN0LFxuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzLFxuICAgIGlkOiBpZEZyb21Qcm9wcyxcbiAgICBvbkJsdXI6ICgpID0+IHtcbiAgICAgIHNldElzRm9jdXNlZChmYWxzZSk7XG4gICAgICBvbkJsdXIgPT09IG51bGwgfHwgb25CbHVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkJsdXIoKTtcbiAgICB9LFxuICAgIG9uRm9jdXM6ICgpID0+IHtcbiAgICAgIHNldElzRm9jdXNlZCh0cnVlKTtcbiAgICAgIG9uRm9jdXMgPT09IG51bGwgfHwgb25Gb2N1cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Gb2N1cygpO1xuICAgIH0sXG4gICAgcmVmOiBlbGVtZW50UmVmLFxuICAgIHJvbGU6IFwic2VwYXJhdG9yXCIsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgLi4uc3R5bGVGcm9tUHJvcHNcbiAgICB9LFxuICAgIHRhYkluZGV4LFxuICAgIC8vIENTUyBzZWxlY3RvcnNcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtZGlyZWN0aW9uXCI6IGRpcmVjdGlvbixcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtaWRcIjogZ3JvdXBJZCxcbiAgICBcImRhdGEtcmVzaXplLWhhbmRsZVwiOiBcIlwiLFxuICAgIFwiZGF0YS1yZXNpemUtaGFuZGxlLWFjdGl2ZVwiOiBzdGF0ZSA9PT0gXCJkcmFnXCIgPyBcInBvaW50ZXJcIiA6IGlzRm9jdXNlZCA/IFwia2V5Ym9hcmRcIiA6IHVuZGVmaW5lZCxcbiAgICBcImRhdGEtcmVzaXplLWhhbmRsZS1zdGF0ZVwiOiBzdGF0ZSxcbiAgICBcImRhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1lbmFibGVkXCI6ICFkaXNhYmxlZCxcbiAgICBcImRhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1pZFwiOiByZXNpemVIYW5kbGVJZFxuICB9KTtcbn1cblBhbmVsUmVzaXplSGFuZGxlLmRpc3BsYXlOYW1lID0gXCJQYW5lbFJlc2l6ZUhhbmRsZVwiO1xuXG5mdW5jdGlvbiBnZXRQYW5lbEVsZW1lbnQoaWQsIHNjb3BlID0gZG9jdW1lbnQpIHtcbiAgY29uc3QgZWxlbWVudCA9IHNjb3BlLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXBhbmVsLWlkPVwiJHtpZH1cIl1gKTtcbiAgaWYgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0UGFuZWxFbGVtZW50c0Zvckdyb3VwKGdyb3VwSWQsIHNjb3BlID0gZG9jdW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oc2NvcGUucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtcGFuZWxdW2RhdGEtcGFuZWwtZ3JvdXAtaWQ9XCIke2dyb3VwSWR9XCJdYCkpO1xufVxuXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RpbmdSZWN0YW5nbGUocmVjdE9uZSwgcmVjdFR3bywgc3RyaWN0KSB7XG4gIGlmICghaW50ZXJzZWN0cyhyZWN0T25lLCByZWN0VHdvLCBzdHJpY3QpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5tYXgocmVjdE9uZS54LCByZWN0VHdvLngpLFxuICAgIHk6IE1hdGgubWF4KHJlY3RPbmUueSwgcmVjdFR3by55KSxcbiAgICB3aWR0aDogTWF0aC5taW4ocmVjdE9uZS54ICsgcmVjdE9uZS53aWR0aCwgcmVjdFR3by54ICsgcmVjdFR3by53aWR0aCkgLSBNYXRoLm1heChyZWN0T25lLngsIHJlY3RUd28ueCksXG4gICAgaGVpZ2h0OiBNYXRoLm1pbihyZWN0T25lLnkgKyByZWN0T25lLmhlaWdodCwgcmVjdFR3by55ICsgcmVjdFR3by5oZWlnaHQpIC0gTWF0aC5tYXgocmVjdE9uZS55LCByZWN0VHdvLnkpXG4gIH07XG59XG5cbmV4cG9ydCB7IFBhbmVsLCBQYW5lbEdyb3VwLCBQYW5lbFJlc2l6ZUhhbmRsZSwgYXNzZXJ0LCBnZXRJbnRlcnNlY3RpbmdSZWN0YW5nbGUsIGdldFBhbmVsRWxlbWVudCwgZ2V0UGFuZWxFbGVtZW50c0Zvckdyb3VwLCBnZXRQYW5lbEdyb3VwRWxlbWVudCwgZ2V0UmVzaXplSGFuZGxlRWxlbWVudCwgZ2V0UmVzaXplSGFuZGxlRWxlbWVudEluZGV4LCBnZXRSZXNpemVIYW5kbGVFbGVtZW50c0Zvckdyb3VwLCBnZXRSZXNpemVIYW5kbGVQYW5lbElkcywgaW50ZXJzZWN0cyB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUNvbnRleHQiLCJjcmVhdGVSZWYiLCJmb3J3YXJkUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZUxheW91dEVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUlkIiwidG9TdHJpbmciLCJQYW5lbEdyb3VwQ29udGV4dCIsImRpc3BsYXlOYW1lIiwid3JhcHBlZFVzZUlkIiwiY291bnRlciIsInVzZVVuaXF1ZUlkIiwiaWRGcm9tUGFyYW1zIiwiaWRGcm9tVXNlSWQiLCJpZFJlZiIsImN1cnJlbnQiLCJQYW5lbFdpdGhGb3J3YXJkZWRSZWYiLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsImNsYXNzTmFtZUZyb21Qcm9wcyIsImNvbGxhcHNlZFNpemUiLCJjb2xsYXBzaWJsZSIsImRlZmF1bHRTaXplIiwiZm9yd2FyZGVkUmVmIiwiaWQiLCJpZEZyb21Qcm9wcyIsIm1heFNpemUiLCJtaW5TaXplIiwib25Db2xsYXBzZSIsIm9uRXhwYW5kIiwib25SZXNpemUiLCJvcmRlciIsInN0eWxlIiwic3R5bGVGcm9tUHJvcHMiLCJ0YWdOYW1lIiwiVHlwZSIsInJlc3QiLCJjb250ZXh0IiwiRXJyb3IiLCJjb2xsYXBzZVBhbmVsIiwiZXhwYW5kUGFuZWwiLCJnZXRQYW5lbFNpemUiLCJnZXRQYW5lbFN0eWxlIiwiZ3JvdXBJZCIsImlzUGFuZWxDb2xsYXBzZWQiLCJyZWV2YWx1YXRlUGFuZWxDb25zdHJhaW50cyIsInJlZ2lzdGVyUGFuZWwiLCJyZXNpemVQYW5lbCIsInVucmVnaXN0ZXJQYW5lbCIsInBhbmVsSWQiLCJwYW5lbERhdGFSZWYiLCJjYWxsYmFja3MiLCJjb25zdHJhaW50cyIsImlkSXNGcm9tUHJvcHMiLCJ1bmRlZmluZWQiLCJkZXZXYXJuaW5nc1JlZiIsImRpZExvZ01pc3NpbmdEZWZhdWx0U2l6ZVdhcm5pbmciLCJjb25zb2xlIiwid2FybiIsImNvbGxhcHNlIiwiZXhwYW5kIiwiZ2V0SWQiLCJnZXRTaXplIiwiaXNDb2xsYXBzZWQiLCJpc0V4cGFuZGVkIiwicmVzaXplIiwic2l6ZSIsInBhcnNlRmxvYXQiLCJmbGV4R3JvdyIsInRvRml4ZWQiLCJQYW5lbCIsInByb3BzIiwicmVmIiwiY3VycmVudEN1cnNvclN0eWxlIiwic3R5bGVFbGVtZW50IiwiZ2V0Q3Vyc29yU3R5bGUiLCJzdGF0ZSIsImNvbnN0cmFpbnRGbGFncyIsImhvcml6b250YWxNaW4iLCJFWENFRURFRF9IT1JJWk9OVEFMX01JTiIsImhvcml6b250YWxNYXgiLCJFWENFRURFRF9IT1JJWk9OVEFMX01BWCIsInZlcnRpY2FsTWluIiwiRVhDRUVERURfVkVSVElDQUxfTUlOIiwidmVydGljYWxNYXgiLCJFWENFRURFRF9WRVJUSUNBTF9NQVgiLCJyZXNldEdsb2JhbEN1cnNvclN0eWxlIiwiZG9jdW1lbnQiLCJoZWFkIiwicmVtb3ZlQ2hpbGQiLCJzZXRHbG9iYWxDdXJzb3JTdHlsZSIsImFwcGVuZENoaWxkIiwiaW5uZXJIVE1MIiwiaXNLZXlEb3duIiwiZXZlbnQiLCJ0eXBlIiwiaXNQb2ludGVyRXZlbnQiLCJzdGFydHNXaXRoIiwiaXNNb3VzZUV2ZW50IiwiZ2V0UmVzaXplRXZlbnRDb29yZGluYXRlcyIsImlzUHJpbWFyeSIsIngiLCJjbGllbnRYIiwieSIsImNsaWVudFkiLCJJbmZpbml0eSIsImdldElucHV0VHlwZSIsIm1hdGNoTWVkaWEiLCJtYXRjaGVzIiwiaW50ZXJzZWN0cyIsInJlY3RPbmUiLCJyZWN0VHdvIiwic3RyaWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJjb21wYXJlIiwiYSIsImIiLCJhbmNlc3RvcnMiLCJnZXRfYW5jZXN0b3JzIiwiY29tbW9uX2FuY2VzdG9yIiwiYXQiLCJwb3AiLCJhc3NlcnQiLCJ6X2luZGV4ZXMiLCJnZXRfel9pbmRleCIsImZpbmRfc3RhY2tpbmdfY29udGV4dCIsImNoaWxkTm9kZXMiLCJmdXJ0aGVzdF9hbmNlc3RvcnMiLCJpIiwibGVuZ3RoIiwiY2hpbGQiLCJNYXRoIiwic2lnbiIsImlzX2ZsZXhfaXRlbSIsIm5vZGUiLCJfZ2V0X3BhcmVudCIsImRpc3BsYXkiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0X3BhcmVudCIsImNyZWF0ZXNfc3RhY2tpbmdfY29udGV4dCIsInBvc2l0aW9uIiwiekluZGV4Iiwib3BhY2l0eSIsInRyYW5zZm9ybSIsIndlYmtpdFRyYW5zZm9ybSIsIm1peEJsZW5kTW9kZSIsImZpbHRlciIsIndlYmtpdEZpbHRlciIsImlzb2xhdGlvbiIsInRlc3QiLCJ3aWxsQ2hhbmdlIiwid2Via2l0T3ZlcmZsb3dTY3JvbGxpbmciLCJub2RlcyIsIk51bWJlciIsInB1c2giLCJwYXJlbnROb2RlIiwiU2hhZG93Um9vdCIsImhvc3QiLCJpc0NvYXJzZVBvaW50ZXIiLCJpbnRlcnNlY3RpbmdIYW5kbGVzIiwiaXNQb2ludGVyRG93biIsIm93bmVyRG9jdW1lbnRDb3VudHMiLCJNYXAiLCJwYW5lbENvbnN0cmFpbnRGbGFncyIsInJlZ2lzdGVyZWRSZXNpemVIYW5kbGVycyIsIlNldCIsInJlZ2lzdGVyUmVzaXplSGFuZGxlIiwicmVzaXplSGFuZGxlSWQiLCJlbGVtZW50IiwiZGlyZWN0aW9uIiwiaGl0QXJlYU1hcmdpbnMiLCJzZXRSZXNpemVIYW5kbGVyU3RhdGUiLCJfb3duZXJEb2N1bWVudENvdW50cyQiLCJvd25lckRvY3VtZW50IiwiZGF0YSIsImNvdW50IiwiZ2V0Iiwic2V0IiwiYWRkIiwidXBkYXRlTGlzdGVuZXJzIiwidW5yZWdpc3RlclJlc2l6ZUhhbmRsZSIsIl9vd25lckRvY3VtZW50Q291bnRzJDIiLCJkZWxldGUiLCJpbmNsdWRlcyIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsInVwZGF0ZUN1cnNvciIsImhhbmRsZVBvaW50ZXJEb3duIiwidGFyZ2V0IiwicmVjYWxjdWxhdGVJbnRlcnNlY3RpbmdIYW5kbGVzIiwidXBkYXRlUmVzaXplSGFuZGxlclN0YXRlcyIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiaGFuZGxlUG9pbnRlck1vdmUiLCJoYW5kbGVQb2ludGVyVXAiLCJjbGVhciIsInRhcmdldEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImZvckVhY2giLCJkcmFnSGFuZGxlRWxlbWVudCIsImRyYWdIYW5kbGVSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwidG9wIiwibWFyZ2luIiwiY29hcnNlIiwiZmluZSIsImV2ZW50SW50ZXJzZWN0cyIsImNvbnRhaW5zIiwiY3VycmVudEVsZW1lbnQiLCJkaWRJbnRlcnNlY3QiLCJwYXJlbnRFbGVtZW50IiwicmVwb3J0Q29uc3RyYWludHNWaW9sYXRpb24iLCJmbGFnIiwiaW50ZXJzZWN0c0hvcml6b250YWwiLCJpbnRlcnNlY3RzVmVydGljYWwiLCJfIiwiYm9keSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiY2FwdHVyZSIsImFjdGlvbiIsImlzQWN0aXZlIiwiZXhwZWN0ZWRDb25kaXRpb24iLCJtZXNzYWdlIiwiZXJyb3IiLCJQUkVDSVNJT04iLCJmdXp6eUNvbXBhcmVOdW1iZXJzIiwiYWN0dWFsIiwiZXhwZWN0ZWQiLCJmcmFjdGlvbkRpZ2l0cyIsImZ1enp5TnVtYmVyc0VxdWFsJDEiLCJmdXp6eU51bWJlcnNFcXVhbCIsImZ1enp5TGF5b3V0c0VxdWFsIiwiYWN0dWFsU2l6ZSIsImV4cGVjdGVkU2l6ZSIsInBhbmVsQ29uc3RyYWludHMiLCJwYW5lbENvbnN0cmFpbnRzQXJyYXkiLCJwYW5lbEluZGV4IiwiaGFsZndheVBvaW50IiwibWluIiwiYWRqdXN0TGF5b3V0QnlEZWx0YSIsImRlbHRhIiwiaW5pdGlhbExheW91dCIsInBpdm90SW5kaWNlcyIsInByZXZMYXlvdXQiLCJ0cmlnZ2VyIiwibmV4dExheW91dCIsImZpcnN0UGl2b3RJbmRleCIsInNlY29uZFBpdm90SW5kZXgiLCJkZWx0YUFwcGxpZWQiLCJwcmV2U2l6ZSIsImxvY2FsRGVsdGEiLCJhYnMiLCJpbmNyZW1lbnQiLCJtYXhBdmFpbGFibGVEZWx0YSIsIm1heFNhZmVTaXplIiwibWluQWJzRGVsdGEiLCJwaXZvdEluZGV4IiwiZGVsdGFSZW1haW5pbmciLCJ1bnNhZmVTaXplIiwic2FmZVNpemUiLCJ0b1ByZWNpc2lvbiIsImxvY2FsZUNvbXBhcmUiLCJudW1lcmljIiwidG90YWxTaXplIiwicmVkdWNlIiwidG90YWwiLCJnZXRSZXNpemVIYW5kbGVFbGVtZW50c0Zvckdyb3VwIiwic2NvcGUiLCJBcnJheSIsImZyb20iLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0UmVzaXplSGFuZGxlRWxlbWVudEluZGV4IiwiaGFuZGxlcyIsImZpbmRJbmRleCIsImhhbmRsZSIsImdldEF0dHJpYnV0ZSIsImRldGVybWluZVBpdm90SW5kaWNlcyIsImRyYWdIYW5kbGVJZCIsInBhbmVsR3JvdXBFbGVtZW50IiwiZ2V0UGFuZWxHcm91cEVsZW1lbnQiLCJyb290RWxlbWVudCIsIl9kYXRhc2V0IiwiZGF0YXNldCIsInBhbmVsR3JvdXBJZCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRSZXNpemVIYW5kbGVFbGVtZW50IiwiZ2V0UmVzaXplSGFuZGxlUGFuZWxJZHMiLCJoYW5kbGVJZCIsInBhbmVsc0FycmF5IiwiX3BhbmVsc0FycmF5JGluZGV4JGlkIiwiX3BhbmVsc0FycmF5JGluZGV4IiwiX3BhbmVsc0FycmF5JGlkIiwiX3BhbmVsc0FycmF5IiwiaWRCZWZvcmUiLCJpZEFmdGVyIiwidXNlV2luZG93U3BsaXR0ZXJQYW5lbEdyb3VwQmVoYXZpb3IiLCJjb21taXR0ZWRWYWx1ZXNSZWYiLCJlYWdlclZhbHVlc1JlZiIsImxheW91dCIsInBhbmVsRGF0YUFycmF5Iiwic2V0TGF5b3V0IiwiZGlkV2FybkFib3V0TWlzc2luZ1Jlc2l6ZUhhbmRsZSIsImVhZ2VyVmFsdWVzIiwiZ3JvdXBFbGVtZW50IiwiY2xlYW51cEZ1bmN0aW9ucyIsIm1hcCIsIm9uS2V5RG93biIsImRlZmF1bHRQcmV2ZW50ZWQiLCJrZXkiLCJwYW5lbERhdGEiLCJjbGVhbnVwRnVuY3Rpb24iLCJhcmVFcXVhbCIsImFycmF5QSIsImFycmF5QiIsImdldFJlc2l6ZUV2ZW50Q3Vyc29yUG9zaXRpb24iLCJpc0hvcml6b250YWwiLCJjYWxjdWxhdGVEcmFnT2Zmc2V0UGVyY2VudGFnZSIsImluaXRpYWxEcmFnU3RhdGUiLCJoYW5kbGVFbGVtZW50IiwiaW5pdGlhbEN1cnNvclBvc2l0aW9uIiwiY3Vyc29yUG9zaXRpb24iLCJncm91cFJlY3QiLCJncm91cFNpemVJblBpeGVscyIsIm9mZnNldFBpeGVscyIsIm9mZnNldFBlcmNlbnRhZ2UiLCJjYWxjdWxhdGVEZWx0YVBlcmNlbnRhZ2UiLCJrZXlib2FyZFJlc2l6ZUJ5Iiwic2hpZnRLZXkiLCJtb3ZlbWVudCIsImNhbGxQYW5lbENhbGxiYWNrcyIsInBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXAiLCJsYXN0Tm90aWZpZWRTaXplIiwiY29tcGFyZUxheW91dHMiLCJjb21wdXRlUGFuZWxGbGV4Qm94U3R5bGUiLCJkcmFnU3RhdGUiLCJwcmVjaXNpb24iLCJmbGV4QmFzaXMiLCJmbGV4U2hyaW5rIiwib3ZlcmZsb3ciLCJwb2ludGVyRXZlbnRzIiwiZGVib3VuY2UiLCJjYWxsYmFjayIsImR1cmF0aW9uTXMiLCJ0aW1lb3V0SWQiLCJjYWxsYWJsZSIsImFyZ3MiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiaW5pdGlhbGl6ZURlZmF1bHRTdG9yYWdlIiwic3RvcmFnZU9iamVjdCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJuYW1lIiwic2V0SXRlbSIsInZhbHVlIiwiZ2V0UGFuZWxHcm91cEtleSIsImF1dG9TYXZlSWQiLCJnZXRQYW5lbEtleSIsInBhbmVscyIsInBhbmVsIiwiSlNPTiIsInN0cmluZ2lmeSIsInNvcnQiLCJqb2luIiwibG9hZFNlcmlhbGl6ZWRQYW5lbEdyb3VwU3RhdGUiLCJzdG9yYWdlIiwicGFuZWxHcm91cEtleSIsInNlcmlhbGl6ZWQiLCJwYXJzZWQiLCJwYXJzZSIsInNhdmVQYW5lbEdyb3VwU3RhdGUiLCJwYW5lbFNpemVzQmVmb3JlQ29sbGFwc2UiLCJzaXplcyIsIl9sb2FkU2VyaWFsaXplZFBhbmVsRzIiLCJwYW5lbEtleSIsImV4cGFuZFRvU2l6ZXMiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJ2YWxpZGF0ZVBhbmVsQ29uc3RyYWludHMiLCJ3YXJuaW5ncyIsInZhbGlkYXRlUGFuZWxHcm91cExheW91dCIsIm5leHRMYXlvdXRUb3RhbFNpemUiLCJhY2N1bXVsYXRlZCIsInJlbWFpbmluZ1NpemUiLCJMT0NBTF9TVE9SQUdFX0RFQk9VTkNFX0lOVEVSVkFMIiwiZGVmYXVsdFN0b3JhZ2UiLCJkZWJvdW5jZU1hcCIsIlBhbmVsR3JvdXBXaXRoRm9yd2FyZGVkUmVmIiwib25MYXlvdXQiLCJwYW5lbEdyb3VwRWxlbWVudFJlZiIsInNldERyYWdTdGF0ZSIsInBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYiLCJwYW5lbFNpemVCZWZvcmVDb2xsYXBzZVJlZiIsInByZXZEZWx0YVJlZiIsInBhbmVsRGF0YUFycmF5Q2hhbmdlZCIsImRpZExvZ0lkQW5kT3JkZXJXYXJuaW5nIiwiZGlkTG9nUGFuZWxDb25zdHJhaW50c1dhcm5pbmciLCJwcmV2UGFuZWxJZHMiLCJnZXRMYXlvdXQiLCJ1bnNhZmVMYXlvdXQiLCJzYWZlTGF5b3V0IiwiZGVib3VuY2VkU2F2ZSIsImNsb25lZFBhbmVsRGF0YUFycmF5IiwiY2xvbmVkUGFuZWxTaXplc0JlZm9yZUNvbGxhcHNlIiwicGFuZWxJZHMiLCJwYW5lbHNIYXZlQ2hhbmdlZCIsImZpbmQiLCJpc1ZhbGlkIiwicGFuZWxTaXplIiwicGFuZWxEYXRhSGVscGVyIiwiaXNMYXN0UGFuZWwiLCJmaW5kUGFuZWxEYXRhSW5kZXgiLCJtaW5TaXplT3ZlcnJpZGUiLCJtaW5TaXplRnJvbVByb3BzIiwicHJldlBhbmVsU2l6ZSIsImJhc2VTaXplIiwiaXNQYW5lbEV4cGFuZGVkIiwicGFuZWxBIiwicGFuZWxCIiwib3JkZXJBIiwib3JkZXJCIiwicmVzaXplSGFuZGxlciIsImRpciIsImxheW91dENoYW5nZWQiLCJ1bnNhZmVQYW5lbFNpemUiLCJwcmV2Q29uc3RyYWludHMiLCJwcmV2Q29sbGFwc2VkU2l6ZSIsInByZXZDb2xsYXBzaWJsZSIsIm5leHRDb2xsYXBzZWRTaXplIiwibmV4dENvbGxhcHNpYmxlIiwibmV4dE1heFNpemUiLCJuZXh0TWluU2l6ZSIsInN0YXJ0RHJhZ2dpbmciLCJzdG9wRHJhZ2dpbmciLCJmbGV4RGlyZWN0aW9uIiwiUHJvdmlkZXIiLCJQYW5lbEdyb3VwIiwicHJldlBhbmVsRGF0YSIsInVzZVdpbmRvd1NwbGl0dGVyUmVzaXplSGFuZGxlckJlaGF2aW9yIiwiZGlzYWJsZWQiLCJuZXh0SW5kZXgiLCJuZXh0SGFuZGxlIiwiZm9jdXMiLCJQYW5lbFJlc2l6ZUhhbmRsZSIsIm9uQmx1ciIsIm9uRHJhZ2dpbmciLCJvbkZvY3VzIiwidGFiSW5kZXgiLCJfaGl0QXJlYU1hcmdpbnMkY29hcnMiLCJfaGl0QXJlYU1hcmdpbnMkZmluZSIsImVsZW1lbnRSZWYiLCJjYWxsYmFja3NSZWYiLCJwYW5lbEdyb3VwQ29udGV4dCIsInJlZ2lzdGVyUmVzaXplSGFuZGxlV2l0aFBhcmVudEdyb3VwIiwic2V0U3RhdGUiLCJpc0ZvY3VzZWQiLCJzZXRJc0ZvY3VzZWQiLCJzZXRSZXNpemVIYW5kbGVyIiwiY29hcnNlSGl0QXJlYU1hcmdpbnMiLCJmaW5lSGl0QXJlYU1hcmdpbnMiLCJ0b3VjaEFjdGlvbiIsInVzZXJTZWxlY3QiLCJyb2xlIiwiZ2V0UGFuZWxFbGVtZW50IiwiZ2V0UGFuZWxFbGVtZW50c0Zvckdyb3VwIiwiZ2V0SW50ZXJzZWN0aW5nUmVjdGFuZ2xlIiwibWF4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js\n");

/***/ })

};
;